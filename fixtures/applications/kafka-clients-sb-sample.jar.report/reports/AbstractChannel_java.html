<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <title>Source Report for AbstractChannel.java</title>
    <link href="resources/css/bootstrap.min.css" rel="stylesheet"/>
    <link href="resources/css/font-awesome.min.css" rel="stylesheet" />
    <link href="resources/css/windup.css" rel="stylesheet" media="screen"/>
    <link rel="stylesheet" type="text/css" href="resources/libraries/snippet/jquery.snippet.min.css" />
    <link rel="stylesheet" type="text/css" href="resources/css/windup-source.css" />
    <link rel="stylesheet" type="text/css" href="resources/libraries/sausage/sausage.css" />

<link href="resources/img/WINDUP/favicon.png" rel="shortcut icon" type="image/x-icon"/>
    <script src="resources/js/jquery-3.3.1.min.js"></script>
</head>
<body role="document" class="source-report">

    <div class="navbar navbar-inverse navbar-fixed-top" id="main-navbar" style="display: none">
        <div class="wu-navbar-header navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <span class="wu-navbar-header">
<strong class="wu-navbar-header">Windup</strong>
<img align="right" class="wu-navbar-header" src="resources/img/WINDUP/brand-horizontal.png" />            </span>        </div>


                <div class="navbar-collapse collapse navbar-responsive-collapse project-specific" data-project-id="4423800">
    <ul class="nav navbar-nav">
            <li class="">
                <a href="../index.html"><i class="glyphicon glyphicon-home"></i> All Applications</a>
            </li>



                <li class="">
                    <a href="report_index_kafka_clients_sb_sample.html">
                        <i class="glyphicon glyphicon-dashboard"></i>
                      Dashboard
                    </a>
                </li>


                <li class="">
                    <a href="migration_issues.html">
                        <i class="glyphicon glyphicon-warning-sign"></i>
                      Issues
                    </a>
                </li>


                <li class="">
                    <a href="ApplicationDetails_kafka_clients_sb_sample.html">
                        <i class="glyphicon glyphicon-th-list"></i>
                      Application Details
                    </a>
                </li>


                <li class="">
                    <a href="techReport_kafka_clients_sb_sample.html">
                        <i class="fa fa-rocket"></i>
                      Technologies
                    </a>
                </li>


                <li class="">
                    <a href="dependency_graph_report.html">
                        <i class="glyphicon glyphicon-tree-deciduous"></i>
                      Dependencies Graph
                    </a>
                </li>


                <li class="">
                    <a href="Unparsable_kafka_clients_sb_sample.html">
                        <i class="glyphicon glyphicon-warning-sign"></i>
                      Unparsable
                    </a>
                </li>


                <li class="">
                    <a href="dependency_report_kafka_clients_sb_sample.html">
                        <i class="glyphicon glyphicon-retweet"></i>
                      Dependencies
                    </a>
                </li>


                <li class="">
                    <a href="remotereport_kafka_clients_sb_sample.html">
                        <i class="glyphicon service-nav-logo"></i>
                      Remote Services
                    </a>
                </li>


                <li class="">
                    <a href="ignoredfiles_kafka_clients_sb_sample.html">
                        <i class="glyphicon glyphicon-eye-close"></i>
                      Ignored Files
                    </a>
                </li>


                <li class="">
                    <a href="about_kafka_clients_sb_sample.html">
                        <i class="fa fa-question-circle"></i>
                      About
                    </a>
                </li>
    </ul>
    <ul class="nav navbar-nav navbar-right">
<li>
    <a href="#" class="feedback-nav-btn jiraFeedbackTrigger"><i class="glyphicon glyphicon-comment"></i> Send Feedback </a>
</li>


    <script type="text/javascript" src="https://issues.redhat.com/s/f215932e68571747ac58d0f5d554396f-T/en_US-r7luaf/6346/82/1.4.16/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector.js?locale=en-US&amp;collectorId=8b9e338b"></script>

    <script type="text/javascript">

    var FEEDBACK_JS_ADDED = false;
    var FEEDBACK_FORM_TRIGGER = null;

    function displayFeedbackForm() {
        FEEDBACK_FORM_TRIGGER();
    }

    window.ATL_JQ_PAGE_PROPS = {
        "triggerFunction": function(showCollectorDialog) {
            FEEDBACK_FORM_TRIGGER = showCollectorDialog;
        }
    };

    document.addEventListener("DOMContentLoaded", function(event) {
            jQuery(".jiraFeedbackTrigger").click(function(e) {
                e.preventDefault();
                displayFeedbackForm();
            });
    });
    </script>
    </ul>
                </div><!-- /.nav-collapse -->
    </div>


    <div class="container-fluid" role="main">
        <div class="row">
            <div class="page-header page-header-no-border">
                <h1>
                    <div class="main">Source Report
                    <i class="glyphicon glyphicon-info-sign" data-toggle="tooltip" data-placement=right title="This report displays what Tackle Analysis found in individual files. Each item is shown below the line it was found on, and next to it, you may find a link to the rule which it was found by."></i></div>

                        <div class="path project-specific" data-project-id="4423800">
                            kafka-clients-sb-sample.jar/BOOT-INF/lib/netty-transport-4.1.51.Final.jar/io/netty/channel/AbstractChannel.java
                        </div>
                </h1>
            </div>
        </div>

        <div class="row">
            <div class="container-fluid theme-showcase" role="main">

                <div class="panel panel-primary">
                    <div class="panel-heading">
                        <h3 class="panel-title">Information</h3>
                    </div>
                    <div class="panel-body" style="overflow: auto;">

                        <!--<div style="height: 120pt; float:left;"></div> Keeps the minimal height. -->
                        <div class="points" style="text-align: center; color: #00254b; padding-bottom: 1ex;">
                            <div class="number">0</div>
                            <div>Story Points</div>
                        </div>

                        <div class="info" style="margin-left: 95pt;">


                                <h4>Technologies</h4>
                                <div class="technologies" style="overflow: auto"><!-- "auto" to contain all the tags. -->
                                        <span class="label label-info" title="INFORMATIONAL">Decompiled Java File</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                </div>

                                <ul class="classifications">
                                            <li>
                                                <div class="title">
                                                    <em>Threads</em>
<a title='View Rule: javase-01000' href='windup_ruleproviders.html#javase-01000'><span class='glyphicon glyphicon-link rule-link'></span></a>                                                </div>
                                                <div class="desc">The application uses Thread APIs.</div>
                                            </li>
                                </ul>


                            <div style="clear: both;"/><!-- Snaps under the height keeper. Yes, the same effect could be achieved by a table. -->
                        </div><!-- .info -->
                    </div>
                </div>



                <pre id="source">
package io.netty.channel;

import io.netty.buffer.ByteBufAllocator;
import io.netty.channel.Channel.Unsafe;
import io.netty.channel.RecvByteBufAllocator.Handle;
import io.netty.channel.socket.ChannelOutputShutdownEvent;
import io.netty.channel.socket.ChannelOutputShutdownException;
import io.netty.util.DefaultAttributeMap;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.PlatformDependent;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;
import java.io.IOException;
import java.net.ConnectException;
import java.net.InetSocketAddress;
import java.net.NoRouteToHostException;
import java.net.SocketAddress;
import java.net.SocketException;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.NotYetConnectedException;
import java.util.concurrent.Executor;
import java.util.concurrent.RejectedExecutionException;

public abstract class AbstractChannel extends DefaultAttributeMap implements Channel {
   private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractChannel.class);
   private final Channel parent;
   private final ChannelId id;
   private final Unsafe unsafe;
   private final DefaultChannelPipeline pipeline;
   private final VoidChannelPromise unsafeVoidPromise = new VoidChannelPromise(this, false);
   private final AbstractChannel.CloseFuture closeFuture = new AbstractChannel.CloseFuture(this);
   private volatile SocketAddress localAddress;
   private volatile SocketAddress remoteAddress;
   private volatile EventLoop eventLoop;
   private volatile boolean registered;
   private boolean closeInitiated;
   private Throwable initialCloseCause;
   private boolean strValActive;
   private String strVal;

   protected AbstractChannel(Channel parent) {
      this.parent = parent;
      this.id = this.newId();
      this.unsafe = this.newUnsafe();
      this.pipeline = this.newChannelPipeline();
   }

   protected AbstractChannel(Channel parent, ChannelId id) {
      this.parent = parent;
      this.id = id;
      this.unsafe = this.newUnsafe();
      this.pipeline = this.newChannelPipeline();
   }

   public final ChannelId id() {
      return this.id;
   }

   protected ChannelId newId() {
      return DefaultChannelId.newInstance();
   }

   protected DefaultChannelPipeline newChannelPipeline() {
      return new DefaultChannelPipeline(this);
   }

   public boolean isWritable() {
      ChannelOutboundBuffer buf = this.unsafe.outboundBuffer();
      return buf != null &amp;&amp; buf.isWritable();
   }

   public long bytesBeforeUnwritable() {
      ChannelOutboundBuffer buf = this.unsafe.outboundBuffer();
      return buf != null ? buf.bytesBeforeUnwritable() : 0L;
   }

   public long bytesBeforeWritable() {
      ChannelOutboundBuffer buf = this.unsafe.outboundBuffer();
      return buf != null ? buf.bytesBeforeWritable() : Long.MAX_VALUE;
   }

   public Channel parent() {
      return this.parent;
   }

   public ChannelPipeline pipeline() {
      return this.pipeline;
   }

   public ByteBufAllocator alloc() {
      return this.config().getAllocator();
   }

   public EventLoop eventLoop() {
      EventLoop eventLoop = this.eventLoop;
      if (eventLoop == null) {
         throw new IllegalStateException(&quot;channel not registered to an event loop&quot;);
      } else {
         return eventLoop;
      }
   }

   public SocketAddress localAddress() {
      SocketAddress localAddress = this.localAddress;
      if (localAddress == null) {
         try {
            this.localAddress = localAddress = this.unsafe().localAddress();
         } catch (Error var3) {
            throw var3;
         } catch (Throwable var4) {
            return null;
         }
      }

      return localAddress;
   }

   /** @deprecated */
   @Deprecated
   protected void invalidateLocalAddress() {
      this.localAddress = null;
   }

   public SocketAddress remoteAddress() {
      SocketAddress remoteAddress = this.remoteAddress;
      if (remoteAddress == null) {
         try {
            this.remoteAddress = remoteAddress = this.unsafe().remoteAddress();
         } catch (Error var3) {
            throw var3;
         } catch (Throwable var4) {
            return null;
         }
      }

      return remoteAddress;
   }

   /** @deprecated */
   @Deprecated
   protected void invalidateRemoteAddress() {
      this.remoteAddress = null;
   }

   public boolean isRegistered() {
      return this.registered;
   }

   public ChannelFuture bind(SocketAddress localAddress) {
      return this.pipeline.bind(localAddress);
   }

   public ChannelFuture connect(SocketAddress remoteAddress) {
      return this.pipeline.connect(remoteAddress);
   }

   public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress) {
      return this.pipeline.connect(remoteAddress, localAddress);
   }

   public ChannelFuture disconnect() {
      return this.pipeline.disconnect();
   }

   public ChannelFuture close() {
      return this.pipeline.close();
   }

   public ChannelFuture deregister() {
      return this.pipeline.deregister();
   }

   public Channel flush() {
      this.pipeline.flush();
      return this;
   }

   public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) {
      return this.pipeline.bind(localAddress, promise);
   }

   public ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) {
      return this.pipeline.connect(remoteAddress, promise);
   }

   public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {
      return this.pipeline.connect(remoteAddress, localAddress, promise);
   }

   public ChannelFuture disconnect(ChannelPromise promise) {
      return this.pipeline.disconnect(promise);
   }

   public ChannelFuture close(ChannelPromise promise) {
      return this.pipeline.close(promise);
   }

   public ChannelFuture deregister(ChannelPromise promise) {
      return this.pipeline.deregister(promise);
   }

   public Channel read() {
      this.pipeline.read();
      return this;
   }

   public ChannelFuture write(Object msg) {
      return this.pipeline.write(msg);
   }

   public ChannelFuture write(Object msg, ChannelPromise promise) {
      return this.pipeline.write(msg, promise);
   }

   public ChannelFuture writeAndFlush(Object msg) {
      return this.pipeline.writeAndFlush(msg);
   }

   public ChannelFuture writeAndFlush(Object msg, ChannelPromise promise) {
      return this.pipeline.writeAndFlush(msg, promise);
   }

   public ChannelPromise newPromise() {
      return this.pipeline.newPromise();
   }

   public ChannelProgressivePromise newProgressivePromise() {
      return this.pipeline.newProgressivePromise();
   }

   public ChannelFuture newSucceededFuture() {
      return this.pipeline.newSucceededFuture();
   }

   public ChannelFuture newFailedFuture(Throwable cause) {
      return this.pipeline.newFailedFuture(cause);
   }

   public ChannelFuture closeFuture() {
      return this.closeFuture;
   }

   public Unsafe unsafe() {
      return this.unsafe;
   }

   protected abstract AbstractChannel.AbstractUnsafe newUnsafe();

   public final int hashCode() {
      return this.id.hashCode();
   }

   public final boolean equals(Object o) {
      return this == o;
   }

   public final int compareTo(Channel o) {
      return this == o ? 0 : this.id().compareTo(o.id());
   }

   public String toString() {
      boolean active = this.isActive();
      if (this.strValActive == active &amp;&amp; this.strVal != null) {
         return this.strVal;
      } else {
         SocketAddress remoteAddr = this.remoteAddress();
         SocketAddress localAddr = this.localAddress();
         StringBuilder buf;
         if (remoteAddr != null) {
            buf = (new StringBuilder(96)).append(&quot;[id: 0x&quot;).append(this.id.asShortText()).append(&quot;, L:&quot;).append(localAddr).append(active ? &quot; - &quot; : &quot; ! &quot;).append(&quot;R:&quot;).append(remoteAddr).append(&#39;]&#39;);
            this.strVal = buf.toString();
         } else if (localAddr != null) {
            buf = (new StringBuilder(64)).append(&quot;[id: 0x&quot;).append(this.id.asShortText()).append(&quot;, L:&quot;).append(localAddr).append(&#39;]&#39;);
            this.strVal = buf.toString();
         } else {
            buf = (new StringBuilder(16)).append(&quot;[id: 0x&quot;).append(this.id.asShortText()).append(&#39;]&#39;);
            this.strVal = buf.toString();
         }

         this.strValActive = active;
         return this.strVal;
      }
   }

   public final ChannelPromise voidPromise() {
      return this.pipeline.voidPromise();
   }

   protected abstract boolean isCompatible(EventLoop var1);

   protected abstract SocketAddress localAddress0();

   protected abstract SocketAddress remoteAddress0();

   protected void doRegister() throws Exception {
   }

   protected abstract void doBind(SocketAddress var1) throws Exception;

   protected abstract void doDisconnect() throws Exception;

   protected abstract void doClose() throws Exception;

   protected void doShutdownOutput() throws Exception {
      this.doClose();
   }

   protected void doDeregister() throws Exception {
   }

   protected abstract void doBeginRead() throws Exception;

   protected abstract void doWrite(ChannelOutboundBuffer var1) throws Exception;

   protected Object filterOutboundMessage(Object msg) throws Exception {
      return msg;
   }

   protected void validateFileRegion(DefaultFileRegion region, long position) throws IOException {
      DefaultFileRegion.validate(region, position);
   }

   private static final class AnnotatedSocketException extends SocketException {
      private static final long serialVersionUID = 3896743275010454039L;

      AnnotatedSocketException(SocketException exception, SocketAddress remoteAddress) {
         super(exception.getMessage() + &quot;: &quot; + remoteAddress);
         this.initCause(exception);
      }

      public Throwable fillInStackTrace() {
         return this;
      }
   }

   private static final class AnnotatedNoRouteToHostException extends NoRouteToHostException {
      private static final long serialVersionUID = -6801433937592080623L;

      AnnotatedNoRouteToHostException(NoRouteToHostException exception, SocketAddress remoteAddress) {
         super(exception.getMessage() + &quot;: &quot; + remoteAddress);
         this.initCause(exception);
      }

      public Throwable fillInStackTrace() {
         return this;
      }
   }

   private static final class AnnotatedConnectException extends ConnectException {
      private static final long serialVersionUID = 3901958112696433556L;

      AnnotatedConnectException(ConnectException exception, SocketAddress remoteAddress) {
         super(exception.getMessage() + &quot;: &quot; + remoteAddress);
         this.initCause(exception);
      }

      public Throwable fillInStackTrace() {
         return this;
      }
   }

   static final class CloseFuture extends DefaultChannelPromise {
      CloseFuture(AbstractChannel ch) {
         super(ch);
      }

      public ChannelPromise setSuccess() {
         throw new IllegalStateException();
      }

      public ChannelPromise setFailure(Throwable cause) {
         throw new IllegalStateException();
      }

      public boolean trySuccess() {
         throw new IllegalStateException();
      }

      public boolean tryFailure(Throwable cause) {
         throw new IllegalStateException();
      }

      boolean setClosed() {
         return super.trySuccess();
      }
   }

   protected abstract class AbstractUnsafe implements Unsafe {
      private volatile ChannelOutboundBuffer outboundBuffer = new ChannelOutboundBuffer(AbstractChannel.this);
      private Handle recvHandle;
      private boolean inFlush0;
      private boolean neverRegistered = true;

      private void assertEventLoop() {
         assert !AbstractChannel.this.registered || AbstractChannel.this.eventLoop.inEventLoop();

      }

      public Handle recvBufAllocHandle() {
         if (this.recvHandle == null) {
            this.recvHandle = AbstractChannel.this.config().getRecvByteBufAllocator().newHandle();
         }

         return this.recvHandle;
      }

      public final ChannelOutboundBuffer outboundBuffer() {
         return this.outboundBuffer;
      }

      public final SocketAddress localAddress() {
         return AbstractChannel.this.localAddress0();
      }

      public final SocketAddress remoteAddress() {
         return AbstractChannel.this.remoteAddress0();
      }

      public final void register(EventLoop eventLoop, final ChannelPromise promise) {
         ObjectUtil.checkNotNull(eventLoop, &quot;eventLoop&quot;);
         if (AbstractChannel.this.isRegistered()) {
            promise.setFailure(new IllegalStateException(&quot;registered to an event loop already&quot;));
         } else if (!AbstractChannel.this.isCompatible(eventLoop)) {
            promise.setFailure(new IllegalStateException(&quot;incompatible event loop type: &quot; + eventLoop.getClass().getName()));
         } else {
            AbstractChannel.this.eventLoop = eventLoop;
            if (eventLoop.inEventLoop()) {
               this.register0(promise);
            } else {
               try {
                  eventLoop.execute(new Runnable() {
                     public void run() {
                        AbstractUnsafe.this.register0(promise);
                     }
                  });
               } catch (Throwable var4) {
                  AbstractChannel.logger.warn(&quot;Force-closing a channel whose registration task was not accepted by an event loop: {}&quot;, AbstractChannel.this, var4);
                  this.closeForcibly();
                  AbstractChannel.this.closeFuture.setClosed();
                  this.safeSetFailure(promise, var4);
               }
            }

         }
      }

      private void register0(ChannelPromise promise) {
         try {
            if (!promise.setUncancellable() || !this.ensureOpen(promise)) {
               return;
            }

            boolean firstRegistration = this.neverRegistered;
            AbstractChannel.this.doRegister();
            this.neverRegistered = false;
            AbstractChannel.this.registered = true;
            AbstractChannel.this.pipeline.invokeHandlerAddedIfNeeded();
            this.safeSetSuccess(promise);
            AbstractChannel.this.pipeline.fireChannelRegistered();
            if (AbstractChannel.this.isActive()) {
               if (firstRegistration) {
                  AbstractChannel.this.pipeline.fireChannelActive();
               } else if (AbstractChannel.this.config().isAutoRead()) {
                  this.beginRead();
               }
            }
         } catch (Throwable var3) {
            this.closeForcibly();
            AbstractChannel.this.closeFuture.setClosed();
            this.safeSetFailure(promise, var3);
         }

      }

      public final void bind(SocketAddress localAddress, ChannelPromise promise) {
         this.assertEventLoop();
         if (promise.setUncancellable() &amp;&amp; this.ensureOpen(promise)) {
            if (Boolean.TRUE.equals(AbstractChannel.this.config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp; localAddress instanceof InetSocketAddress &amp;&amp; !((InetSocketAddress)localAddress).getAddress().isAnyLocalAddress() &amp;&amp; !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) {
               AbstractChannel.logger.warn(&quot;A non-root user can&#39;t receive a broadcast packet if the socket is not bound to a wildcard address; binding to a non-wildcard address (&quot; + localAddress + &quot;) anyway as requested.&quot;);
            }

            boolean wasActive = AbstractChannel.this.isActive();

            try {
               AbstractChannel.this.doBind(localAddress);
            } catch (Throwable var5) {
               this.safeSetFailure(promise, var5);
               this.closeIfClosed();
               return;
            }

            if (!wasActive &amp;&amp; AbstractChannel.this.isActive()) {
               this.invokeLater(new Runnable() {
                  public void run() {
                     AbstractChannel.this.pipeline.fireChannelActive();
                  }
               });
            }

            this.safeSetSuccess(promise);
         }
      }

      public final void disconnect(ChannelPromise promise) {
         this.assertEventLoop();
         if (promise.setUncancellable()) {
            boolean wasActive = AbstractChannel.this.isActive();

            try {
               AbstractChannel.this.doDisconnect();
               AbstractChannel.this.remoteAddress = null;
               AbstractChannel.this.localAddress = null;
            } catch (Throwable var4) {
               this.safeSetFailure(promise, var4);
               this.closeIfClosed();
               return;
            }

            if (wasActive &amp;&amp; !AbstractChannel.this.isActive()) {
               this.invokeLater(new Runnable() {
                  public void run() {
                     AbstractChannel.this.pipeline.fireChannelInactive();
                  }
               });
            }

            this.safeSetSuccess(promise);
            this.closeIfClosed();
         }
      }

      public final void close(ChannelPromise promise) {
         this.assertEventLoop();
         ClosedChannelException closedChannelException = new ClosedChannelException();
         this.close(promise, closedChannelException, closedChannelException, false);
      }

      public final void shutdownOutput(ChannelPromise promise) {
         this.assertEventLoop();
         this.shutdownOutput(promise, (Throwable)null);
      }

      private void shutdownOutput(final ChannelPromise promise, Throwable cause) {
         if (promise.setUncancellable()) {
            final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
            if (outboundBuffer == null) {
               promise.setFailure(new ClosedChannelException());
            } else {
               this.outboundBuffer = null;
               final Throwable shutdownCause = cause == null ? new ChannelOutputShutdownException(&quot;Channel output shutdown&quot;) : new ChannelOutputShutdownException(&quot;Channel output shutdown&quot;, cause);
               Executor closeExecutor = this.prepareToClose();
               if (closeExecutor != null) {
                  closeExecutor.execute(new Runnable() {
                     public void run() {
                        try {
                           AbstractChannel.this.doShutdownOutput();
                           promise.setSuccess();
                        } catch (Throwable var5) {
                           promise.setFailure(var5);
                        } finally {
                           AbstractChannel.this.eventLoop().execute(new Runnable() {
                              public void run() {
                                 AbstractUnsafe.this.closeOutboundBufferForShutdown(AbstractChannel.this.pipeline, outboundBuffer, shutdownCause);
                              }
                           });
                        }

                     }
                  });
               } else {
                  try {
                     AbstractChannel.this.doShutdownOutput();
                     promise.setSuccess();
                  } catch (Throwable var10) {
                     promise.setFailure(var10);
                  } finally {
                     this.closeOutboundBufferForShutdown(AbstractChannel.this.pipeline, outboundBuffer, shutdownCause);
                  }
               }

            }
         }
      }

      private void closeOutboundBufferForShutdown(ChannelPipeline pipeline, ChannelOutboundBuffer buffer, Throwable cause) {
         buffer.failFlushed(cause, false);
         buffer.close(cause, true);
         pipeline.fireUserEventTriggered(ChannelOutputShutdownEvent.INSTANCE);
      }

      private void close(final ChannelPromise promise, final Throwable cause, final ClosedChannelException closeCause, final boolean notify) {
         if (promise.setUncancellable()) {
            if (AbstractChannel.this.closeInitiated) {
               if (AbstractChannel.this.closeFuture.isDone()) {
                  this.safeSetSuccess(promise);
               } else if (!(promise instanceof VoidChannelPromise)) {
                  AbstractChannel.this.closeFuture.addListener(new ChannelFutureListener() {
                     public void operationComplete(ChannelFuture future) throws Exception {
                        promise.setSuccess();
                     }
                  });
               }

            } else {
               AbstractChannel.this.closeInitiated = true;
               final boolean wasActive = AbstractChannel.this.isActive();
               final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
               this.outboundBuffer = null;
               Executor closeExecutor = this.prepareToClose();
               if (closeExecutor != null) {
                  closeExecutor.execute(new Runnable() {
                     public void run() {
                        try {
                           AbstractUnsafe.this.doClose0(promise);
                        } finally {
                           AbstractUnsafe.this.invokeLater(new Runnable() {
                              public void run() {
                                 if (outboundBuffer != null) {
                                    outboundBuffer.failFlushed(cause, notify);
                                    outboundBuffer.close(closeCause);
                                 }

                                 AbstractUnsafe.this.fireChannelInactiveAndDeregister(wasActive);
                              }
                           });
                        }

                     }
                  });
               } else {
                  try {
                     this.doClose0(promise);
                  } finally {
                     if (outboundBuffer != null) {
                        outboundBuffer.failFlushed(cause, notify);
                        outboundBuffer.close(closeCause);
                     }

                  }

                  if (this.inFlush0) {
                     this.invokeLater(new Runnable() {
                        public void run() {
                           AbstractUnsafe.this.fireChannelInactiveAndDeregister(wasActive);
                        }
                     });
                  } else {
                     this.fireChannelInactiveAndDeregister(wasActive);
                  }
               }

            }
         }
      }

      private void doClose0(ChannelPromise promise) {
         try {
            AbstractChannel.this.doClose();
            AbstractChannel.this.closeFuture.setClosed();
            this.safeSetSuccess(promise);
         } catch (Throwable var3) {
            AbstractChannel.this.closeFuture.setClosed();
            this.safeSetFailure(promise, var3);
         }

      }

      private void fireChannelInactiveAndDeregister(boolean wasActive) {
         this.deregister(this.voidPromise(), wasActive &amp;&amp; !AbstractChannel.this.isActive());
      }

      public final void closeForcibly() {
         this.assertEventLoop();

         try {
            AbstractChannel.this.doClose();
         } catch (Exception var2) {
            AbstractChannel.logger.warn(&quot;Failed to close a channel.&quot;, var2);
         }

      }

      public final void deregister(ChannelPromise promise) {
         this.assertEventLoop();
         this.deregister(promise, false);
      }

      private void deregister(final ChannelPromise promise, final boolean fireChannelInactive) {
         if (promise.setUncancellable()) {
            if (!AbstractChannel.this.registered) {
               this.safeSetSuccess(promise);
            } else {
               this.invokeLater(new Runnable() {
                  public void run() {
                     try {
                        AbstractChannel.this.doDeregister();
                     } catch (Throwable var5) {
                        AbstractChannel.logger.warn(&quot;Unexpected exception occurred while deregistering a channel.&quot;, var5);
                     } finally {
                        if (fireChannelInactive) {
                           AbstractChannel.this.pipeline.fireChannelInactive();
                        }

                        if (AbstractChannel.this.registered) {
                           AbstractChannel.this.registered = false;
                           AbstractChannel.this.pipeline.fireChannelUnregistered();
                        }

                        AbstractUnsafe.this.safeSetSuccess(promise);
                     }

                  }
               });
            }
         }
      }

      public final void beginRead() {
         this.assertEventLoop();
         if (AbstractChannel.this.isActive()) {
            try {
               AbstractChannel.this.doBeginRead();
            } catch (final Exception var2) {
               this.invokeLater(new Runnable() {
                  public void run() {
                     AbstractChannel.this.pipeline.fireExceptionCaught(var2);
                  }
               });
               this.close(this.voidPromise());
            }

         }
      }

      public final void write(Object msg, ChannelPromise promise) {
         this.assertEventLoop();
         ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
         if (outboundBuffer == null) {
            this.safeSetFailure(promise, this.newClosedChannelException(AbstractChannel.this.initialCloseCause));
            ReferenceCountUtil.release(msg);
         } else {
            int size;
            try {
               msg = AbstractChannel.this.filterOutboundMessage(msg);
               size = AbstractChannel.this.pipeline.estimatorHandle().size(msg);
               if (size &lt; 0) {
                  size = 0;
               }
            } catch (Throwable var6) {
               this.safeSetFailure(promise, var6);
               ReferenceCountUtil.release(msg);
               return;
            }

            outboundBuffer.addMessage(msg, size, promise);
         }
      }

      public final void flush() {
         this.assertEventLoop();
         ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
         if (outboundBuffer != null) {
            outboundBuffer.addFlush();
            this.flush0();
         }
      }

      protected void flush0() {
         if (!this.inFlush0) {
            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
            if (outboundBuffer != null &amp;&amp; !outboundBuffer.isEmpty()) {
               this.inFlush0 = true;
               if (!AbstractChannel.this.isActive()) {
                  try {
                     if (AbstractChannel.this.isOpen()) {
                        outboundBuffer.failFlushed(new NotYetConnectedException(), true);
                     } else {
                        outboundBuffer.failFlushed(this.newClosedChannelException(AbstractChannel.this.initialCloseCause), false);
                     }
                  } finally {
                     this.inFlush0 = false;
                  }

               } else {
                  try {
                     AbstractChannel.this.doWrite(outboundBuffer);
                  } catch (Throwable var15) {
                     Throwable t = var15;
                     if (var15 instanceof IOException &amp;&amp; AbstractChannel.this.config().isAutoClose()) {
                        AbstractChannel.this.initialCloseCause = var15;
                        this.close(this.voidPromise(), var15, this.newClosedChannelException(var15), false);
                     } else {
                        try {
                           this.shutdownOutput(this.voidPromise(), t);
                        } catch (Throwable var14) {
                           AbstractChannel.this.initialCloseCause = var15;
                           this.close(this.voidPromise(), var14, this.newClosedChannelException(var15), false);
                        }
                     }
                  } finally {
                     this.inFlush0 = false;
                  }

               }
            }
         }
      }

      private ClosedChannelException newClosedChannelException(Throwable cause) {
         ClosedChannelException exception = new ClosedChannelException();
         if (cause != null) {
            exception.initCause(cause);
         }

         return exception;
      }

      public final ChannelPromise voidPromise() {
         this.assertEventLoop();
         return AbstractChannel.this.unsafeVoidPromise;
      }

      protected final boolean ensureOpen(ChannelPromise promise) {
         if (AbstractChannel.this.isOpen()) {
            return true;
         } else {
            this.safeSetFailure(promise, this.newClosedChannelException(AbstractChannel.this.initialCloseCause));
            return false;
         }
      }

      protected final void safeSetSuccess(ChannelPromise promise) {
         if (!(promise instanceof VoidChannelPromise) &amp;&amp; !promise.trySuccess()) {
            AbstractChannel.logger.warn(&quot;Failed to mark a promise as success because it is done already: {}&quot;, promise);
         }

      }

      protected final void safeSetFailure(ChannelPromise promise, Throwable cause) {
         if (!(promise instanceof VoidChannelPromise) &amp;&amp; !promise.tryFailure(cause)) {
            AbstractChannel.logger.warn(&quot;Failed to mark a promise as failure because it&#39;s done already: {}&quot;, promise, cause);
         }

      }

      protected final void closeIfClosed() {
         if (!AbstractChannel.this.isOpen()) {
            this.close(this.voidPromise());
         }
      }

      private void invokeLater(Runnable task) {
         try {
            AbstractChannel.this.eventLoop().execute(task);
         } catch (RejectedExecutionException var3) {
            AbstractChannel.logger.warn(&quot;Can&#39;t invoke task later as EventLoop rejected it&quot;, var3);
         }

      }

      protected final Throwable annotateConnectException(Throwable cause, SocketAddress remoteAddress) {
         if (cause instanceof ConnectException) {
            return new AbstractChannel.AnnotatedConnectException((ConnectException)cause, remoteAddress);
         } else if (cause instanceof NoRouteToHostException) {
            return new AbstractChannel.AnnotatedNoRouteToHostException((NoRouteToHostException)cause, remoteAddress);
         } else {
            return (Throwable)(cause instanceof SocketException ? new AbstractChannel.AnnotatedSocketException((SocketException)cause, remoteAddress) : cause);
         }
      }

      protected Executor prepareToClose() {
         return null;
      }
   }
}
</pre>
            </div> <!-- /container -->
        </div><!-- /row-->
    </div><!-- /container main-->


<div style="text-align: left; font-size: small; color: gray; font-style: italic;">Page generated: Feb 15, 2023, 10:00:26 PM</div>

    <script src="resources/js/jquery-migrate-1.4.1.min.js"></script>
    <script src="resources/js/bootstrap.min.js"></script>

    <script type="text/javascript" src="resources/libraries/jquery-ui/jquery.ui.widget.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.min.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.java-properties.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.java-manifest.js"></script>
    <script type="text/javascript" src="resources/libraries/sausage/jquery.sausage.min.js"></script>

    <script type="text/javascript">
        var script   = document.createElement("script");
        script.type  = "text/javascript";
            script.src   = "resources/js/navbar.js";
        document.body.appendChild(script);
    </script>

    <script type="text/javascript">
        $(window).on("hashchange", function () {
            window.scrollTo(window.scrollX, window.scrollY - 50);
        });
        function offsetAnchor() {
            if(location.hash.length !== 0) {
                window.scrollTo(window.scrollX, window.scrollY - 50);
            }
        }
        window.setTimeout(function() {
            offsetAnchor();
        }, 1);
        $(document).ready(function(){
            $("pre").snippet("java",{style:"ide-eclipse", showNum:true,boxFill:"#ffeeb9", box: "" });



            if (location.hash) {
                var atag = $("a[name='" + location.hash.substr(1)  +  "']");
                $('html,body').animate({scrollTop: atag.offset().top - 150},'slow');
            }

            $('code[class]').each(function(){
                 var codeSyntax = ($(this).attr('class'));
                 if(codeSyntax) {
                    $(this).parent().snippet(codeSyntax,{style:'ide-eclipse', menu:false, showNum:false});
                 }
            });
            $(window).sausage({ page: 'li.box' });
            $(window).resize(function () {
                $('div.sausage-set').css('top', parseInt($('#main-navbar').css("height")));
            });

            // Deprecated
            // $(window).load(function () {
            //     $('div.sausage-set').css('top', parseInt($('#main-navbar').css("height")));
            // });
            $(window).on('load', function () {
                $('div.sausage-set').css('top', parseInt($('#main-navbar').css("height")));
            });
        });

        function qs(key) {
            key = key.replace(/[*+?^$.\[\]{}()|\\\/]/g, "\\$&"); // escape RegEx meta chars
            var match = location.search.match(new RegExp("[?&]"+key+"=([^&]+)(&|$)"));
            return match && decodeURIComponent(match[1].replace(/\+/g, " "));
        }

        $(document).ready(function() {
            var defaultProjectID = 4423800;
            var selectedProject = qs("project");
            if (!selectedProject)
                selectedProject = defaultProjectID;

            $(".project-specific").each(function(index, element) {
                var currentProject = $(element).data("project-id");

                if (currentProject == selectedProject)
                    $(element).show();
                else
                    $(element).remove();
            });
            $("#main-navbar").show();
        });
    </script>
    <script>$(document).ready(function(){$('[data-toggle="tooltip"]').tooltip();});</script>
</body>
</html>
