<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <title>Source Report for DefaultChannelPipeline.java</title>
    <link href="resources/css/bootstrap.min.css" rel="stylesheet"/>
    <link href="resources/css/font-awesome.min.css" rel="stylesheet" />
    <link href="resources/css/windup.css" rel="stylesheet" media="screen"/>
    <link rel="stylesheet" type="text/css" href="resources/libraries/snippet/jquery.snippet.min.css" />
    <link rel="stylesheet" type="text/css" href="resources/css/windup-source.css" />
    <link rel="stylesheet" type="text/css" href="resources/libraries/sausage/sausage.css" />

<link href="resources/img/WINDUP/favicon.png" rel="shortcut icon" type="image/x-icon"/>
    <script src="resources/js/jquery-3.3.1.min.js"></script>
</head>
<body role="document" class="source-report">

    <div class="navbar navbar-inverse navbar-fixed-top" id="main-navbar" style="display: none">
        <div class="wu-navbar-header navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <span class="wu-navbar-header">
<strong class="wu-navbar-header">Windup</strong>
<img align="right" class="wu-navbar-header" src="resources/img/WINDUP/brand-horizontal.png" />            </span>        </div>


                <div class="navbar-collapse collapse navbar-responsive-collapse project-specific" data-project-id="4423800">
    <ul class="nav navbar-nav">
            <li class="">
                <a href="../index.html"><i class="glyphicon glyphicon-home"></i> All Applications</a>
            </li>



                <li class="">
                    <a href="report_index_kafka_clients_sb_sample.html">
                        <i class="glyphicon glyphicon-dashboard"></i>
                      Dashboard
                    </a>
                </li>


                <li class="">
                    <a href="migration_issues.html">
                        <i class="glyphicon glyphicon-warning-sign"></i>
                      Issues
                    </a>
                </li>


                <li class="">
                    <a href="ApplicationDetails_kafka_clients_sb_sample.html">
                        <i class="glyphicon glyphicon-th-list"></i>
                      Application Details
                    </a>
                </li>


                <li class="">
                    <a href="techReport_kafka_clients_sb_sample.html">
                        <i class="fa fa-rocket"></i>
                      Technologies
                    </a>
                </li>


                <li class="">
                    <a href="dependency_graph_report.html">
                        <i class="glyphicon glyphicon-tree-deciduous"></i>
                      Dependencies Graph
                    </a>
                </li>


                <li class="">
                    <a href="Unparsable_kafka_clients_sb_sample.html">
                        <i class="glyphicon glyphicon-warning-sign"></i>
                      Unparsable
                    </a>
                </li>


                <li class="">
                    <a href="dependency_report_kafka_clients_sb_sample.html">
                        <i class="glyphicon glyphicon-retweet"></i>
                      Dependencies
                    </a>
                </li>


                <li class="">
                    <a href="remotereport_kafka_clients_sb_sample.html">
                        <i class="glyphicon service-nav-logo"></i>
                      Remote Services
                    </a>
                </li>


                <li class="">
                    <a href="ignoredfiles_kafka_clients_sb_sample.html">
                        <i class="glyphicon glyphicon-eye-close"></i>
                      Ignored Files
                    </a>
                </li>


                <li class="">
                    <a href="about_kafka_clients_sb_sample.html">
                        <i class="fa fa-question-circle"></i>
                      About
                    </a>
                </li>
    </ul>
    <ul class="nav navbar-nav navbar-right">
<li>
    <a href="#" class="feedback-nav-btn jiraFeedbackTrigger"><i class="glyphicon glyphicon-comment"></i> Send Feedback </a>
</li>


    <script type="text/javascript" src="https://issues.redhat.com/s/f215932e68571747ac58d0f5d554396f-T/en_US-r7luaf/6346/82/1.4.16/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector.js?locale=en-US&amp;collectorId=8b9e338b"></script>

    <script type="text/javascript">

    var FEEDBACK_JS_ADDED = false;
    var FEEDBACK_FORM_TRIGGER = null;

    function displayFeedbackForm() {
        FEEDBACK_FORM_TRIGGER();
    }

    window.ATL_JQ_PAGE_PROPS = {
        "triggerFunction": function(showCollectorDialog) {
            FEEDBACK_FORM_TRIGGER = showCollectorDialog;
        }
    };

    document.addEventListener("DOMContentLoaded", function(event) {
            jQuery(".jiraFeedbackTrigger").click(function(e) {
                e.preventDefault();
                displayFeedbackForm();
            });
    });
    </script>
    </ul>
                </div><!-- /.nav-collapse -->
    </div>


    <div class="container-fluid" role="main">
        <div class="row">
            <div class="page-header page-header-no-border">
                <h1>
                    <div class="main">Source Report
                    <i class="glyphicon glyphicon-info-sign" data-toggle="tooltip" data-placement=right title="This report displays what Tackle Analysis found in individual files. Each item is shown below the line it was found on, and next to it, you may find a link to the rule which it was found by."></i></div>

                        <div class="path project-specific" data-project-id="4423800">
                            kafka-clients-sb-sample.jar/BOOT-INF/lib/netty-transport-4.1.51.Final.jar/io/netty/channel/DefaultChannelPipeline.java
                        </div>
                </h1>
            </div>
        </div>

        <div class="row">
            <div class="container-fluid theme-showcase" role="main">

                <div class="panel panel-primary">
                    <div class="panel-heading">
                        <h3 class="panel-title">Information</h3>
                    </div>
                    <div class="panel-body" style="overflow: auto;">

                        <!--<div style="height: 120pt; float:left;"></div> Keeps the minimal height. -->
                        <div class="points" style="text-align: center; color: #00254b; padding-bottom: 1ex;">
                            <div class="number">0</div>
                            <div>Story Points</div>
                        </div>

                        <div class="info" style="margin-left: 95pt;">


                                <h4>Technologies</h4>
                                <div class="technologies" style="overflow: auto"><!-- "auto" to contain all the tags. -->
                                        <span class="label label-info" title="INFORMATIONAL">Decompiled Java File</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                </div>

                                <ul class="classifications">
                                            <li>
                                                <div class="title">
                                                    <em>Threads</em>
<a title='View Rule: javase-01000' href='windup_ruleproviders.html#javase-01000'><span class='glyphicon glyphicon-link rule-link'></span></a>                                                </div>
                                                <div class="desc">The application uses Thread APIs.</div>
                                            </li>
                                </ul>


                            <div style="clear: both;"/><!-- Snaps under the height keeper. Yes, the same effect could be achieved by a table. -->
                        </div><!-- .info -->
                    </div>
                </div>



                <pre id="source">
package io.netty.channel;

import io.netty.channel.Channel.Unsafe;
import io.netty.channel.MessageSizeEstimator.Handle;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.ResourceLeakDetector;
import io.netty.util.concurrent.EventExecutor;
import io.netty.util.concurrent.EventExecutorGroup;
import io.netty.util.concurrent.FastThreadLocal;
import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.StringUtil;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;
import java.net.SocketAddress;
import java.util.ArrayList;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.WeakHashMap;
import java.util.Map.Entry;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

public class DefaultChannelPipeline implements ChannelPipeline {
   static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultChannelPipeline.class);
   private static final String HEAD_NAME = generateName0(DefaultChannelPipeline.HeadContext.class);
   private static final String TAIL_NAME = generateName0(DefaultChannelPipeline.TailContext.class);
   private static final FastThreadLocal&lt;Map&lt;Class&lt;?&gt;, String&gt;&gt; nameCaches = new FastThreadLocal&lt;Map&lt;Class&lt;?&gt;, String&gt;&gt;() {
      protected Map&lt;Class&lt;?&gt;, String&gt; initialValue() {
         return new WeakHashMap();
      }
   };
   private static final AtomicReferenceFieldUpdater&lt;DefaultChannelPipeline, Handle&gt; ESTIMATOR = AtomicReferenceFieldUpdater.newUpdater(DefaultChannelPipeline.class, Handle.class, &quot;estimatorHandle&quot;);
   final AbstractChannelHandlerContext head;
   final AbstractChannelHandlerContext tail;
   private final Channel channel;
   private final ChannelFuture succeededFuture;
   private final VoidChannelPromise voidPromise;
   private final boolean touch = ResourceLeakDetector.isEnabled();
   private Map&lt;EventExecutorGroup, EventExecutor&gt; childExecutors;
   private volatile Handle estimatorHandle;
   private boolean firstRegistration = true;
   private DefaultChannelPipeline.PendingHandlerCallback pendingHandlerCallbackHead;
   private boolean registered;

   protected DefaultChannelPipeline(Channel channel) {
      this.channel = (Channel)ObjectUtil.checkNotNull(channel, &quot;channel&quot;);
      this.succeededFuture = new SucceededChannelFuture(channel, (EventExecutor)null);
      this.voidPromise = new VoidChannelPromise(channel, true);
      this.tail = new DefaultChannelPipeline.TailContext(this);
      this.head = new DefaultChannelPipeline.HeadContext(this);
      this.head.next = this.tail;
      this.tail.prev = this.head;
   }

   final Handle estimatorHandle() {
      Handle handle = this.estimatorHandle;
      if (handle == null) {
         handle = this.channel.config().getMessageSizeEstimator().newHandle();
         if (!ESTIMATOR.compareAndSet(this, (Object)null, handle)) {
            handle = this.estimatorHandle;
         }
      }

      return handle;
   }

   final Object touch(Object msg, AbstractChannelHandlerContext next) {
      return this.touch ? ReferenceCountUtil.touch(msg, next) : msg;
   }

   private AbstractChannelHandlerContext newContext(EventExecutorGroup group, String name, ChannelHandler handler) {
      return new DefaultChannelHandlerContext(this, this.childExecutor(group), name, handler);
   }

   private EventExecutor childExecutor(EventExecutorGroup group) {
      if (group == null) {
         return null;
      } else {
         Boolean pinEventExecutor = (Boolean)this.channel.config().getOption(ChannelOption.SINGLE_EVENTEXECUTOR_PER_GROUP);
         if (pinEventExecutor != null &amp;&amp; !pinEventExecutor.booleanValue()) {
            return group.next();
         } else {
            Map&lt;EventExecutorGroup, EventExecutor&gt; childExecutors = this.childExecutors;
            if (childExecutors == null) {
               childExecutors = this.childExecutors = new IdentityHashMap(4);
            }

            EventExecutor childExecutor = (EventExecutor)childExecutors.get(group);
            if (childExecutor == null) {
               childExecutor = group.next();
               childExecutors.put(group, childExecutor);
            }

            return childExecutor;
         }
      }
   }

   public final Channel channel() {
      return this.channel;
   }

   public final ChannelPipeline addFirst(String name, ChannelHandler handler) {
      return this.addFirst((EventExecutorGroup)null, name, handler);
   }

   public final ChannelPipeline addFirst(EventExecutorGroup group, String name, ChannelHandler handler) {
      AbstractChannelHandlerContext newCtx;
      synchronized(this) {
         checkMultiplicity(handler);
         name = this.filterName(name, handler);
         newCtx = this.newContext(group, name, handler);
         this.addFirst0(newCtx);
         if (!this.registered) {
            newCtx.setAddPending();
            this.callHandlerCallbackLater(newCtx, true);
            return this;
         }

         EventExecutor executor = newCtx.executor();
         if (!executor.inEventLoop()) {
            this.callHandlerAddedInEventLoop(newCtx, executor);
            return this;
         }
      }

      this.callHandlerAdded0(newCtx);
      return this;
   }

   private void addFirst0(AbstractChannelHandlerContext newCtx) {
      AbstractChannelHandlerContext nextCtx = this.head.next;
      newCtx.prev = this.head;
      newCtx.next = nextCtx;
      this.head.next = newCtx;
      nextCtx.prev = newCtx;
   }

   public final ChannelPipeline addLast(String name, ChannelHandler handler) {
      return this.addLast((EventExecutorGroup)null, name, handler);
   }

   public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) {
      AbstractChannelHandlerContext newCtx;
      synchronized(this) {
         checkMultiplicity(handler);
         newCtx = this.newContext(group, this.filterName(name, handler), handler);
         this.addLast0(newCtx);
         if (!this.registered) {
            newCtx.setAddPending();
            this.callHandlerCallbackLater(newCtx, true);
            return this;
         }

         EventExecutor executor = newCtx.executor();
         if (!executor.inEventLoop()) {
            this.callHandlerAddedInEventLoop(newCtx, executor);
            return this;
         }
      }

      this.callHandlerAdded0(newCtx);
      return this;
   }

   private void addLast0(AbstractChannelHandlerContext newCtx) {
      AbstractChannelHandlerContext prev = this.tail.prev;
      newCtx.prev = prev;
      newCtx.next = this.tail;
      prev.next = newCtx;
      this.tail.prev = newCtx;
   }

   public final ChannelPipeline addBefore(String baseName, String name, ChannelHandler handler) {
      return this.addBefore((EventExecutorGroup)null, baseName, name, handler);
   }

   public final ChannelPipeline addBefore(EventExecutorGroup group, String baseName, String name, ChannelHandler handler) {
      AbstractChannelHandlerContext newCtx;
      synchronized(this) {
         checkMultiplicity(handler);
         name = this.filterName(name, handler);
         AbstractChannelHandlerContext ctx = this.getContextOrDie(baseName);
         newCtx = this.newContext(group, name, handler);
         addBefore0(ctx, newCtx);
         if (!this.registered) {
            newCtx.setAddPending();
            this.callHandlerCallbackLater(newCtx, true);
            return this;
         }

         EventExecutor executor = newCtx.executor();
         if (!executor.inEventLoop()) {
            this.callHandlerAddedInEventLoop(newCtx, executor);
            return this;
         }
      }

      this.callHandlerAdded0(newCtx);
      return this;
   }

   private static void addBefore0(AbstractChannelHandlerContext ctx, AbstractChannelHandlerContext newCtx) {
      newCtx.prev = ctx.prev;
      newCtx.next = ctx;
      ctx.prev.next = newCtx;
      ctx.prev = newCtx;
   }

   private String filterName(String name, ChannelHandler handler) {
      if (name == null) {
         return this.generateName(handler);
      } else {
         this.checkDuplicateName(name);
         return name;
      }
   }

   public final ChannelPipeline addAfter(String baseName, String name, ChannelHandler handler) {
      return this.addAfter((EventExecutorGroup)null, baseName, name, handler);
   }

   public final ChannelPipeline addAfter(EventExecutorGroup group, String baseName, String name, ChannelHandler handler) {
      AbstractChannelHandlerContext newCtx;
      synchronized(this) {
         checkMultiplicity(handler);
         name = this.filterName(name, handler);
         AbstractChannelHandlerContext ctx = this.getContextOrDie(baseName);
         newCtx = this.newContext(group, name, handler);
         addAfter0(ctx, newCtx);
         if (!this.registered) {
            newCtx.setAddPending();
            this.callHandlerCallbackLater(newCtx, true);
            return this;
         }

         EventExecutor executor = newCtx.executor();
         if (!executor.inEventLoop()) {
            this.callHandlerAddedInEventLoop(newCtx, executor);
            return this;
         }
      }

      this.callHandlerAdded0(newCtx);
      return this;
   }

   private static void addAfter0(AbstractChannelHandlerContext ctx, AbstractChannelHandlerContext newCtx) {
      newCtx.prev = ctx;
      newCtx.next = ctx.next;
      ctx.next.prev = newCtx;
      ctx.next = newCtx;
   }

   public final ChannelPipeline addFirst(ChannelHandler handler) {
      return this.addFirst((String)null, (ChannelHandler)handler);
   }

   public final ChannelPipeline addFirst(ChannelHandler... handlers) {
      return this.addFirst((EventExecutorGroup)null, (ChannelHandler[])handlers);
   }

   public final ChannelPipeline addFirst(EventExecutorGroup executor, ChannelHandler... handlers) {
      ObjectUtil.checkNotNull(handlers, &quot;handlers&quot;);
      if (handlers.length != 0 &amp;&amp; handlers[0] != null) {
         int size;
         for(size = 1; size &lt; handlers.length &amp;&amp; handlers[size] != null; ++size) {
            ;
         }

         for(int i = size - 1; i &gt;= 0; --i) {
            ChannelHandler h = handlers[i];
            this.addFirst(executor, (String)null, h);
         }

         return this;
      } else {
         return this;
      }
   }

   public final ChannelPipeline addLast(ChannelHandler handler) {
      return this.addLast((String)null, (ChannelHandler)handler);
   }

   public final ChannelPipeline addLast(ChannelHandler... handlers) {
      return this.addLast((EventExecutorGroup)null, (ChannelHandler[])handlers);
   }

   public final ChannelPipeline addLast(EventExecutorGroup executor, ChannelHandler... handlers) {
      ObjectUtil.checkNotNull(handlers, &quot;handlers&quot;);
      ChannelHandler[] var3 = handlers;
      int var4 = handlers.length;

      for(int var5 = 0; var5 &lt; var4; ++var5) {
         ChannelHandler h = var3[var5];
         if (h == null) {
            break;
         }

         this.addLast(executor, (String)null, h);
      }

      return this;
   }

   private String generateName(ChannelHandler handler) {
      Map&lt;Class&lt;?&gt;, String&gt; cache = (Map)nameCaches.get();
      Class&lt;?&gt; handlerType = handler.getClass();
      String name = (String)cache.get(handlerType);
      if (name == null) {
         name = generateName0(handlerType);
         cache.put(handlerType, name);
      }

      if (this.context0(name) != null) {
         String baseName = name.substring(0, name.length() - 1);
         int i = 1;

         while(true) {
            String newName = baseName + i;
            if (this.context0(newName) == null) {
               name = newName;
               break;
            }

            ++i;
         }
      }

      return name;
   }

   private static String generateName0(Class&lt;?&gt; handlerType) {
      return StringUtil.simpleClassName(handlerType) + &quot;#0&quot;;
   }

   public final ChannelPipeline remove(ChannelHandler handler) {
      this.remove(this.getContextOrDie(handler));
      return this;
   }

   public final ChannelHandler remove(String name) {
      return this.remove(this.getContextOrDie(name)).handler();
   }

   public final &lt;T extends ChannelHandler&gt; T remove(Class&lt;T&gt; handlerType) {
      return this.remove(this.getContextOrDie(handlerType)).handler();
   }

   public final &lt;T extends ChannelHandler&gt; T removeIfExists(String name) {
      return this.removeIfExists(this.context(name));
   }

   public final &lt;T extends ChannelHandler&gt; T removeIfExists(Class&lt;T&gt; handlerType) {
      return this.removeIfExists(this.context(handlerType));
   }

   public final &lt;T extends ChannelHandler&gt; T removeIfExists(ChannelHandler handler) {
      return this.removeIfExists(this.context(handler));
   }

   private &lt;T extends ChannelHandler&gt; T removeIfExists(ChannelHandlerContext ctx) {
      return ctx == null ? null : this.remove((AbstractChannelHandlerContext)ctx).handler();
   }

   private AbstractChannelHandlerContext remove(final AbstractChannelHandlerContext ctx) {
      assert ctx != this.head &amp;&amp; ctx != this.tail;

      synchronized(this) {
         this.atomicRemoveFromHandlerList(ctx);
         if (!this.registered) {
            this.callHandlerCallbackLater(ctx, false);
            return ctx;
         }

         EventExecutor executor = ctx.executor();
         if (!executor.inEventLoop()) {
            executor.execute(new Runnable() {
               public void run() {
                  DefaultChannelPipeline.this.callHandlerRemoved0(ctx);
               }
            });
            return ctx;
         }
      }

      this.callHandlerRemoved0(ctx);
      return ctx;
   }

   private synchronized void atomicRemoveFromHandlerList(AbstractChannelHandlerContext ctx) {
      AbstractChannelHandlerContext prev = ctx.prev;
      AbstractChannelHandlerContext next = ctx.next;
      prev.next = next;
      next.prev = prev;
   }

   public final ChannelHandler removeFirst() {
      if (this.head.next == this.tail) {
         throw new NoSuchElementException();
      } else {
         return this.remove(this.head.next).handler();
      }
   }

   public final ChannelHandler removeLast() {
      if (this.head.next == this.tail) {
         throw new NoSuchElementException();
      } else {
         return this.remove(this.tail.prev).handler();
      }
   }

   public final ChannelPipeline replace(ChannelHandler oldHandler, String newName, ChannelHandler newHandler) {
      this.replace(this.getContextOrDie(oldHandler), newName, newHandler);
      return this;
   }

   public final ChannelHandler replace(String oldName, String newName, ChannelHandler newHandler) {
      return this.replace(this.getContextOrDie(oldName), newName, newHandler);
   }

   public final &lt;T extends ChannelHandler&gt; T replace(Class&lt;T&gt; oldHandlerType, String newName, ChannelHandler newHandler) {
      return this.replace(this.getContextOrDie(oldHandlerType), newName, newHandler);
   }

   private ChannelHandler replace(final AbstractChannelHandlerContext ctx, String newName, ChannelHandler newHandler) {
      assert ctx != this.head &amp;&amp; ctx != this.tail;

      final AbstractChannelHandlerContext newCtx;
      synchronized(this) {
         checkMultiplicity(newHandler);
         if (newName == null) {
            newName = this.generateName(newHandler);
         } else {
            boolean sameName = ctx.name().equals(newName);
            if (!sameName) {
               this.checkDuplicateName(newName);
            }
         }

         newCtx = this.newContext(ctx.executor, newName, newHandler);
         replace0(ctx, newCtx);
         if (!this.registered) {
            this.callHandlerCallbackLater(newCtx, true);
            this.callHandlerCallbackLater(ctx, false);
            return ctx.handler();
         }

         EventExecutor executor = ctx.executor();
         if (!executor.inEventLoop()) {
            executor.execute(new Runnable() {
               public void run() {
                  DefaultChannelPipeline.this.callHandlerAdded0(newCtx);
                  DefaultChannelPipeline.this.callHandlerRemoved0(ctx);
               }
            });
            return ctx.handler();
         }
      }

      this.callHandlerAdded0(newCtx);
      this.callHandlerRemoved0(ctx);
      return ctx.handler();
   }

   private static void replace0(AbstractChannelHandlerContext oldCtx, AbstractChannelHandlerContext newCtx) {
      AbstractChannelHandlerContext prev = oldCtx.prev;
      AbstractChannelHandlerContext next = oldCtx.next;
      newCtx.prev = prev;
      newCtx.next = next;
      prev.next = newCtx;
      next.prev = newCtx;
      oldCtx.prev = newCtx;
      oldCtx.next = newCtx;
   }

   private static void checkMultiplicity(ChannelHandler handler) {
      if (handler instanceof ChannelHandlerAdapter) {
         ChannelHandlerAdapter h = (ChannelHandlerAdapter)handler;
         if (!h.isSharable() &amp;&amp; h.added) {
            throw new ChannelPipelineException(h.getClass().getName() + &quot; is not a @Sharable handler, so can&#39;t be added or removed multiple times.&quot;);
         }

         h.added = true;
      }

   }

   private void callHandlerAdded0(AbstractChannelHandlerContext ctx) {
      try {
         ctx.callHandlerAdded();
      } catch (Throwable var6) {
         boolean removed = false;

         try {
            this.atomicRemoveFromHandlerList(ctx);
            ctx.callHandlerRemoved();
            removed = true;
         } catch (Throwable var5) {
            if (logger.isWarnEnabled()) {
               logger.warn(&quot;Failed to remove a handler: &quot; + ctx.name(), var5);
            }
         }

         if (removed) {
            this.fireExceptionCaught(new ChannelPipelineException(ctx.handler().getClass().getName() + &quot;.handlerAdded() has thrown an exception; removed.&quot;, var6));
         } else {
            this.fireExceptionCaught(new ChannelPipelineException(ctx.handler().getClass().getName() + &quot;.handlerAdded() has thrown an exception; also failed to remove.&quot;, var6));
         }
      }

   }

   private void callHandlerRemoved0(AbstractChannelHandlerContext ctx) {
      try {
         ctx.callHandlerRemoved();
      } catch (Throwable var3) {
         this.fireExceptionCaught(new ChannelPipelineException(ctx.handler().getClass().getName() + &quot;.handlerRemoved() has thrown an exception.&quot;, var3));
      }

   }

   final void invokeHandlerAddedIfNeeded() {
      assert this.channel.eventLoop().inEventLoop();

      if (this.firstRegistration) {
         this.firstRegistration = false;
         this.callHandlerAddedForAllHandlers();
      }

   }

   public final ChannelHandler first() {
      ChannelHandlerContext first = this.firstContext();
      return first == null ? null : first.handler();
   }

   public final ChannelHandlerContext firstContext() {
      AbstractChannelHandlerContext first = this.head.next;
      return first == this.tail ? null : this.head.next;
   }

   public final ChannelHandler last() {
      AbstractChannelHandlerContext last = this.tail.prev;
      return last == this.head ? null : last.handler();
   }

   public final ChannelHandlerContext lastContext() {
      AbstractChannelHandlerContext last = this.tail.prev;
      return last == this.head ? null : last;
   }

   public final ChannelHandler get(String name) {
      ChannelHandlerContext ctx = this.context(name);
      return ctx == null ? null : ctx.handler();
   }

   public final &lt;T extends ChannelHandler&gt; T get(Class&lt;T&gt; handlerType) {
      ChannelHandlerContext ctx = this.context(handlerType);
      return ctx == null ? null : ctx.handler();
   }

   public final ChannelHandlerContext context(String name) {
      return this.context0((String)ObjectUtil.checkNotNull(name, &quot;name&quot;));
   }

   public final ChannelHandlerContext context(ChannelHandler handler) {
      ObjectUtil.checkNotNull(handler, &quot;handler&quot;);

      for(AbstractChannelHandlerContext ctx = this.head.next; ctx != null; ctx = ctx.next) {
         if (ctx.handler() == handler) {
            return ctx;
         }
      }

      return null;
   }

   public final ChannelHandlerContext context(Class&lt;? extends ChannelHandler&gt; handlerType) {
      ObjectUtil.checkNotNull(handlerType, &quot;handlerType&quot;);

      for(AbstractChannelHandlerContext ctx = this.head.next; ctx != null; ctx = ctx.next) {
         if (handlerType.isAssignableFrom(ctx.handler().getClass())) {
            return ctx;
         }
      }

      return null;
   }

   public final List&lt;String&gt; names() {
      List&lt;String&gt; list = new ArrayList();

      for(AbstractChannelHandlerContext ctx = this.head.next; ctx != null; ctx = ctx.next) {
         list.add(ctx.name());
      }

      return list;
   }

   public final Map&lt;String, ChannelHandler&gt; toMap() {
      Map&lt;String, ChannelHandler&gt; map = new LinkedHashMap();

      for(AbstractChannelHandlerContext ctx = this.head.next; ctx != this.tail; ctx = ctx.next) {
         map.put(ctx.name(), ctx.handler());
      }

      return map;
   }

   public final Iterator&lt;Entry&lt;String, ChannelHandler&gt;&gt; iterator() {
      return this.toMap().entrySet().iterator();
   }

   public final String toString() {
      StringBuilder buf = (new StringBuilder()).append(StringUtil.simpleClassName(this)).append(&#39;{&#39;);
      AbstractChannelHandlerContext ctx = this.head.next;

      while(ctx != this.tail) {
         buf.append(&#39;(&#39;).append(ctx.name()).append(&quot; = &quot;).append(ctx.handler().getClass().getName()).append(&#39;)&#39;);
         ctx = ctx.next;
         if (ctx == this.tail) {
            break;
         }

         buf.append(&quot;, &quot;);
      }

      buf.append(&#39;}&#39;);
      return buf.toString();
   }

   public final ChannelPipeline fireChannelRegistered() {
      AbstractChannelHandlerContext.invokeChannelRegistered(this.head);
      return this;
   }

   public final ChannelPipeline fireChannelUnregistered() {
      AbstractChannelHandlerContext.invokeChannelUnregistered(this.head);
      return this;
   }

   private synchronized void destroy() {
      this.destroyUp(this.head.next, false);
   }

   private void destroyUp(final AbstractChannelHandlerContext ctx, boolean inEventLoop) {
      Thread currentThread = Thread.currentThread();
      AbstractChannelHandlerContext tail = this.tail;

      while(true) {
         if (ctx == tail) {
            this.destroyDown(currentThread, tail.prev, inEventLoop);
            break;
         }

         EventExecutor executor = ctx.executor();
         if (!inEventLoop &amp;&amp; !executor.inEventLoop(currentThread)) {
            executor.execute(new Runnable() {
               public void run() {
                  DefaultChannelPipeline.this.destroyUp(ctx, true);
               }
            });
            break;
         }

         ctx = ctx.next;
         inEventLoop = false;
      }

   }

   private void destroyDown(Thread currentThread, final AbstractChannelHandlerContext ctx, boolean inEventLoop) {
      for(AbstractChannelHandlerContext head = this.head; ctx != head; inEventLoop = false) {
         EventExecutor executor = ctx.executor();
         if (!inEventLoop &amp;&amp; !executor.inEventLoop(currentThread)) {
            executor.execute(new Runnable() {
               public void run() {
                  DefaultChannelPipeline.this.destroyDown(Thread.currentThread(), ctx, true);
               }
            });
            break;
         }

         this.atomicRemoveFromHandlerList(ctx);
         this.callHandlerRemoved0(ctx);
         ctx = ctx.prev;
      }

   }

   public final ChannelPipeline fireChannelActive() {
      AbstractChannelHandlerContext.invokeChannelActive(this.head);
      return this;
   }

   public final ChannelPipeline fireChannelInactive() {
      AbstractChannelHandlerContext.invokeChannelInactive(this.head);
      return this;
   }

   public final ChannelPipeline fireExceptionCaught(Throwable cause) {
      AbstractChannelHandlerContext.invokeExceptionCaught(this.head, cause);
      return this;
   }

   public final ChannelPipeline fireUserEventTriggered(Object event) {
      AbstractChannelHandlerContext.invokeUserEventTriggered(this.head, event);
      return this;
   }

   public final ChannelPipeline fireChannelRead(Object msg) {
      AbstractChannelHandlerContext.invokeChannelRead(this.head, msg);
      return this;
   }

   public final ChannelPipeline fireChannelReadComplete() {
      AbstractChannelHandlerContext.invokeChannelReadComplete(this.head);
      return this;
   }

   public final ChannelPipeline fireChannelWritabilityChanged() {
      AbstractChannelHandlerContext.invokeChannelWritabilityChanged(this.head);
      return this;
   }

   public final ChannelFuture bind(SocketAddress localAddress) {
      return this.tail.bind(localAddress);
   }

   public final ChannelFuture connect(SocketAddress remoteAddress) {
      return this.tail.connect(remoteAddress);
   }

   public final ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress) {
      return this.tail.connect(remoteAddress, localAddress);
   }

   public final ChannelFuture disconnect() {
      return this.tail.disconnect();
   }

   public final ChannelFuture close() {
      return this.tail.close();
   }

   public final ChannelFuture deregister() {
      return this.tail.deregister();
   }

   public final ChannelPipeline flush() {
      this.tail.flush();
      return this;
   }

   public final ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) {
      return this.tail.bind(localAddress, promise);
   }

   public final ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) {
      return this.tail.connect(remoteAddress, promise);
   }

   public final ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {
      return this.tail.connect(remoteAddress, localAddress, promise);
   }

   public final ChannelFuture disconnect(ChannelPromise promise) {
      return this.tail.disconnect(promise);
   }

   public final ChannelFuture close(ChannelPromise promise) {
      return this.tail.close(promise);
   }

   public final ChannelFuture deregister(ChannelPromise promise) {
      return this.tail.deregister(promise);
   }

   public final ChannelPipeline read() {
      this.tail.read();
      return this;
   }

   public final ChannelFuture write(Object msg) {
      return this.tail.write(msg);
   }

   public final ChannelFuture write(Object msg, ChannelPromise promise) {
      return this.tail.write(msg, promise);
   }

   public final ChannelFuture writeAndFlush(Object msg, ChannelPromise promise) {
      return this.tail.writeAndFlush(msg, promise);
   }

   public final ChannelFuture writeAndFlush(Object msg) {
      return this.tail.writeAndFlush(msg);
   }

   public final ChannelPromise newPromise() {
      return new DefaultChannelPromise(this.channel);
   }

   public final ChannelProgressivePromise newProgressivePromise() {
      return new DefaultChannelProgressivePromise(this.channel);
   }

   public final ChannelFuture newSucceededFuture() {
      return this.succeededFuture;
   }

   public final ChannelFuture newFailedFuture(Throwable cause) {
      return new FailedChannelFuture(this.channel, (EventExecutor)null, cause);
   }

   public final ChannelPromise voidPromise() {
      return this.voidPromise;
   }

   private void checkDuplicateName(String name) {
      if (this.context0(name) != null) {
         throw new IllegalArgumentException(&quot;Duplicate handler name: &quot; + name);
      }
   }

   private AbstractChannelHandlerContext context0(String name) {
      for(AbstractChannelHandlerContext context = this.head.next; context != this.tail; context = context.next) {
         if (context.name().equals(name)) {
            return context;
         }
      }

      return null;
   }

   private AbstractChannelHandlerContext getContextOrDie(String name) {
      AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext)this.context(name);
      if (ctx == null) {
         throw new NoSuchElementException(name);
      } else {
         return ctx;
      }
   }

   private AbstractChannelHandlerContext getContextOrDie(ChannelHandler handler) {
      AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext)this.context(handler);
      if (ctx == null) {
         throw new NoSuchElementException(handler.getClass().getName());
      } else {
         return ctx;
      }
   }

   private AbstractChannelHandlerContext getContextOrDie(Class&lt;? extends ChannelHandler&gt; handlerType) {
      AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext)this.context(handlerType);
      if (ctx == null) {
         throw new NoSuchElementException(handlerType.getName());
      } else {
         return ctx;
      }
   }

   private void callHandlerAddedForAllHandlers() {
      DefaultChannelPipeline.PendingHandlerCallback pendingHandlerCallbackHead;
      synchronized(this) {
         assert !this.registered;

         this.registered = true;
         pendingHandlerCallbackHead = this.pendingHandlerCallbackHead;
         this.pendingHandlerCallbackHead = null;
      }

      for(DefaultChannelPipeline.PendingHandlerCallback task = pendingHandlerCallbackHead; task != null; task = task.next) {
         task.execute();
      }

   }

   private void callHandlerCallbackLater(AbstractChannelHandlerContext ctx, boolean added) {
      assert !this.registered;

      DefaultChannelPipeline.PendingHandlerCallback task = added ? new DefaultChannelPipeline.PendingHandlerAddedTask(ctx) : new DefaultChannelPipeline.PendingHandlerRemovedTask(ctx);
      DefaultChannelPipeline.PendingHandlerCallback pending = this.pendingHandlerCallbackHead;
      if (pending == null) {
         this.pendingHandlerCallbackHead = (DefaultChannelPipeline.PendingHandlerCallback)task;
      } else {
         while(pending.next != null) {
            pending = pending.next;
         }

         pending.next = (DefaultChannelPipeline.PendingHandlerCallback)task;
      }

   }

   private void callHandlerAddedInEventLoop(final AbstractChannelHandlerContext newCtx, EventExecutor executor) {
      newCtx.setAddPending();
      executor.execute(new Runnable() {
         public void run() {
            DefaultChannelPipeline.this.callHandlerAdded0(newCtx);
         }
      });
   }

   protected void onUnhandledInboundException(Throwable cause) {
      try {
         logger.warn(&quot;An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.&quot;, cause);
      } finally {
         ReferenceCountUtil.release(cause);
      }

   }

   protected void onUnhandledInboundChannelActive() {
   }

   protected void onUnhandledInboundChannelInactive() {
   }

   protected void onUnhandledInboundMessage(Object msg) {
      try {
         logger.debug(&quot;Discarded inbound message {} that reached at the tail of the pipeline. Please check your pipeline configuration.&quot;, msg);
      } finally {
         ReferenceCountUtil.release(msg);
      }

   }

   protected void onUnhandledInboundMessage(ChannelHandlerContext ctx, Object msg) {
      this.onUnhandledInboundMessage(msg);
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Discarded message pipeline : {}. Channel : {}.&quot;, ctx.pipeline().names(), ctx.channel());
      }

   }

   protected void onUnhandledInboundChannelReadComplete() {
   }

   protected void onUnhandledInboundUserEventTriggered(Object evt) {
      ReferenceCountUtil.release(evt);
   }

   protected void onUnhandledChannelWritabilityChanged() {
   }

   protected void incrementPendingOutboundBytes(long size) {
      ChannelOutboundBuffer buffer = this.channel.unsafe().outboundBuffer();
      if (buffer != null) {
         buffer.incrementPendingOutboundBytes(size);
      }

   }

   protected void decrementPendingOutboundBytes(long size) {
      ChannelOutboundBuffer buffer = this.channel.unsafe().outboundBuffer();
      if (buffer != null) {
         buffer.decrementPendingOutboundBytes(size);
      }

   }

   private final class PendingHandlerRemovedTask extends DefaultChannelPipeline.PendingHandlerCallback {
      PendingHandlerRemovedTask(AbstractChannelHandlerContext ctx) {
         super(ctx);
      }

      public void run() {
         DefaultChannelPipeline.this.callHandlerRemoved0(this.ctx);
      }

      void execute() {
         EventExecutor executor = this.ctx.executor();
         if (executor.inEventLoop()) {
            DefaultChannelPipeline.this.callHandlerRemoved0(this.ctx);
         } else {
            try {
               executor.execute(this);
            } catch (RejectedExecutionException var3) {
               if (DefaultChannelPipeline.logger.isWarnEnabled()) {
                  DefaultChannelPipeline.logger.warn(&quot;Can&#39;t invoke handlerRemoved() as the EventExecutor {} rejected it, removing handler {}.&quot;, new Object[]{executor, this.ctx.name(), var3});
               }

               this.ctx.setRemoved();
            }
         }

      }
   }

   private final class PendingHandlerAddedTask extends DefaultChannelPipeline.PendingHandlerCallback {
      PendingHandlerAddedTask(AbstractChannelHandlerContext ctx) {
         super(ctx);
      }

      public void run() {
         DefaultChannelPipeline.this.callHandlerAdded0(this.ctx);
      }

      void execute() {
         EventExecutor executor = this.ctx.executor();
         if (executor.inEventLoop()) {
            DefaultChannelPipeline.this.callHandlerAdded0(this.ctx);
         } else {
            try {
               executor.execute(this);
            } catch (RejectedExecutionException var3) {
               if (DefaultChannelPipeline.logger.isWarnEnabled()) {
                  DefaultChannelPipeline.logger.warn(&quot;Can&#39;t invoke handlerAdded() as the EventExecutor {} rejected it, removing handler {}.&quot;, new Object[]{executor, this.ctx.name(), var3});
               }

               DefaultChannelPipeline.this.atomicRemoveFromHandlerList(this.ctx);
               this.ctx.setRemoved();
            }
         }

      }
   }

   private abstract static class PendingHandlerCallback implements Runnable {
      final AbstractChannelHandlerContext ctx;
      DefaultChannelPipeline.PendingHandlerCallback next;

      PendingHandlerCallback(AbstractChannelHandlerContext ctx) {
         this.ctx = ctx;
      }

      abstract void execute();
   }

   final class HeadContext extends AbstractChannelHandlerContext implements ChannelOutboundHandler, ChannelInboundHandler {
      private final Unsafe unsafe;

      HeadContext(DefaultChannelPipeline pipeline) {
         super(pipeline, (EventExecutor)null, DefaultChannelPipeline.HEAD_NAME, DefaultChannelPipeline.HeadContext.class);
         this.unsafe = pipeline.channel().unsafe();
         this.setAddComplete();
      }

      public ChannelHandler handler() {
         return this;
      }

      public void handlerAdded(ChannelHandlerContext ctx) {
      }

      public void handlerRemoved(ChannelHandlerContext ctx) {
      }

      public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) {
         this.unsafe.bind(localAddress, promise);
      }

      public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {
         this.unsafe.connect(remoteAddress, localAddress, promise);
      }

      public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) {
         this.unsafe.disconnect(promise);
      }

      public void close(ChannelHandlerContext ctx, ChannelPromise promise) {
         this.unsafe.close(promise);
      }

      public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) {
         this.unsafe.deregister(promise);
      }

      public void read(ChannelHandlerContext ctx) {
         this.unsafe.beginRead();
      }

      public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
         this.unsafe.write(msg, promise);
      }

      public void flush(ChannelHandlerContext ctx) {
         this.unsafe.flush();
      }

      public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         ctx.fireExceptionCaught(cause);
      }

      public void channelRegistered(ChannelHandlerContext ctx) {
         DefaultChannelPipeline.this.invokeHandlerAddedIfNeeded();
         ctx.fireChannelRegistered();
      }

      public void channelUnregistered(ChannelHandlerContext ctx) {
         ctx.fireChannelUnregistered();
         if (!DefaultChannelPipeline.this.channel.isOpen()) {
            DefaultChannelPipeline.this.destroy();
         }

      }

      public void channelActive(ChannelHandlerContext ctx) {
         ctx.fireChannelActive();
         this.readIfIsAutoRead();
      }

      public void channelInactive(ChannelHandlerContext ctx) {
         ctx.fireChannelInactive();
      }

      public void channelRead(ChannelHandlerContext ctx, Object msg) {
         ctx.fireChannelRead(msg);
      }

      public void channelReadComplete(ChannelHandlerContext ctx) {
         ctx.fireChannelReadComplete();
         this.readIfIsAutoRead();
      }

      private void readIfIsAutoRead() {
         if (DefaultChannelPipeline.this.channel.config().isAutoRead()) {
            DefaultChannelPipeline.this.channel.read();
         }

      }

      public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
         ctx.fireUserEventTriggered(evt);
      }

      public void channelWritabilityChanged(ChannelHandlerContext ctx) {
         ctx.fireChannelWritabilityChanged();
      }
   }

   final class TailContext extends AbstractChannelHandlerContext implements ChannelInboundHandler {
      TailContext(DefaultChannelPipeline pipeline) {
         super(pipeline, (EventExecutor)null, DefaultChannelPipeline.TAIL_NAME, DefaultChannelPipeline.TailContext.class);
         this.setAddComplete();
      }

      public ChannelHandler handler() {
         return this;
      }

      public void channelRegistered(ChannelHandlerContext ctx) {
      }

      public void channelUnregistered(ChannelHandlerContext ctx) {
      }

      public void channelActive(ChannelHandlerContext ctx) {
         DefaultChannelPipeline.this.onUnhandledInboundChannelActive();
      }

      public void channelInactive(ChannelHandlerContext ctx) {
         DefaultChannelPipeline.this.onUnhandledInboundChannelInactive();
      }

      public void channelWritabilityChanged(ChannelHandlerContext ctx) {
         DefaultChannelPipeline.this.onUnhandledChannelWritabilityChanged();
      }

      public void handlerAdded(ChannelHandlerContext ctx) {
      }

      public void handlerRemoved(ChannelHandlerContext ctx) {
      }

      public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
         DefaultChannelPipeline.this.onUnhandledInboundUserEventTriggered(evt);
      }

      public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         DefaultChannelPipeline.this.onUnhandledInboundException(cause);
      }

      public void channelRead(ChannelHandlerContext ctx, Object msg) {
         DefaultChannelPipeline.this.onUnhandledInboundMessage(ctx, msg);
      }

      public void channelReadComplete(ChannelHandlerContext ctx) {
         DefaultChannelPipeline.this.onUnhandledInboundChannelReadComplete();
      }
   }
}
</pre>
            </div> <!-- /container -->
        </div><!-- /row-->
    </div><!-- /container main-->


<div style="text-align: left; font-size: small; color: gray; font-style: italic;">Page generated: Feb 15, 2023, 10:00:26 PM</div>

    <script src="resources/js/jquery-migrate-1.4.1.min.js"></script>
    <script src="resources/js/bootstrap.min.js"></script>

    <script type="text/javascript" src="resources/libraries/jquery-ui/jquery.ui.widget.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.min.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.java-properties.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.java-manifest.js"></script>
    <script type="text/javascript" src="resources/libraries/sausage/jquery.sausage.min.js"></script>

    <script type="text/javascript">
        var script   = document.createElement("script");
        script.type  = "text/javascript";
            script.src   = "resources/js/navbar.js";
        document.body.appendChild(script);
    </script>

    <script type="text/javascript">
        $(window).on("hashchange", function () {
            window.scrollTo(window.scrollX, window.scrollY - 50);
        });
        function offsetAnchor() {
            if(location.hash.length !== 0) {
                window.scrollTo(window.scrollX, window.scrollY - 50);
            }
        }
        window.setTimeout(function() {
            offsetAnchor();
        }, 1);
        $(document).ready(function(){
            $("pre").snippet("java",{style:"ide-eclipse", showNum:true,boxFill:"#ffeeb9", box: "" });



            if (location.hash) {
                var atag = $("a[name='" + location.hash.substr(1)  +  "']");
                $('html,body').animate({scrollTop: atag.offset().top - 150},'slow');
            }

            $('code[class]').each(function(){
                 var codeSyntax = ($(this).attr('class'));
                 if(codeSyntax) {
                    $(this).parent().snippet(codeSyntax,{style:'ide-eclipse', menu:false, showNum:false});
                 }
            });
            $(window).sausage({ page: 'li.box' });
            $(window).resize(function () {
                $('div.sausage-set').css('top', parseInt($('#main-navbar').css("height")));
            });

            // Deprecated
            // $(window).load(function () {
            //     $('div.sausage-set').css('top', parseInt($('#main-navbar').css("height")));
            // });
            $(window).on('load', function () {
                $('div.sausage-set').css('top', parseInt($('#main-navbar').css("height")));
            });
        });

        function qs(key) {
            key = key.replace(/[*+?^$.\[\]{}()|\\\/]/g, "\\$&"); // escape RegEx meta chars
            var match = location.search.match(new RegExp("[?&]"+key+"=([^&]+)(&|$)"));
            return match && decodeURIComponent(match[1].replace(/\+/g, " "));
        }

        $(document).ready(function() {
            var defaultProjectID = 4423800;
            var selectedProject = qs("project");
            if (!selectedProject)
                selectedProject = defaultProjectID;

            $(".project-specific").each(function(index, element) {
                var currentProject = $(element).data("project-id");

                if (currentProject == selectedProject)
                    $(element).show();
                else
                    $(element).remove();
            });
            $("#main-navbar").show();
        });
    </script>
    <script>$(document).ready(function(){$('[data-toggle="tooltip"]').tooltip();});</script>
</body>
</html>
