<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <title>Source Report for SingleThreadEventExecutor.java</title>
    <link href="resources/css/bootstrap.min.css" rel="stylesheet"/>
    <link href="resources/css/font-awesome.min.css" rel="stylesheet" />
    <link href="resources/css/windup.css" rel="stylesheet" media="screen"/>
    <link rel="stylesheet" type="text/css" href="resources/libraries/snippet/jquery.snippet.min.css" />
    <link rel="stylesheet" type="text/css" href="resources/css/windup-source.css" />
    <link rel="stylesheet" type="text/css" href="resources/libraries/sausage/sausage.css" />

<link href="resources/img/WINDUP/favicon.png" rel="shortcut icon" type="image/x-icon"/>
    <script src="resources/js/jquery-3.3.1.min.js"></script>
</head>
<body role="document" class="source-report">

    <div class="navbar navbar-inverse navbar-fixed-top" id="main-navbar" style="display: none">
        <div class="wu-navbar-header navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <span class="wu-navbar-header">
<strong class="wu-navbar-header">Windup</strong>
<img align="right" class="wu-navbar-header" src="resources/img/WINDUP/brand-horizontal.png" />            </span>        </div>


                <div class="navbar-collapse collapse navbar-responsive-collapse project-specific" data-project-id="4423800">
    <ul class="nav navbar-nav">
            <li class="">
                <a href="../index.html"><i class="glyphicon glyphicon-home"></i> All Applications</a>
            </li>



                <li class="">
                    <a href="report_index_kafka_clients_sb_sample.html">
                        <i class="glyphicon glyphicon-dashboard"></i>
                      Dashboard
                    </a>
                </li>


                <li class="">
                    <a href="migration_issues.html">
                        <i class="glyphicon glyphicon-warning-sign"></i>
                      Issues
                    </a>
                </li>


                <li class="">
                    <a href="ApplicationDetails_kafka_clients_sb_sample.html">
                        <i class="glyphicon glyphicon-th-list"></i>
                      Application Details
                    </a>
                </li>


                <li class="">
                    <a href="techReport_kafka_clients_sb_sample.html">
                        <i class="fa fa-rocket"></i>
                      Technologies
                    </a>
                </li>


                <li class="">
                    <a href="dependency_graph_report.html">
                        <i class="glyphicon glyphicon-tree-deciduous"></i>
                      Dependencies Graph
                    </a>
                </li>


                <li class="">
                    <a href="Unparsable_kafka_clients_sb_sample.html">
                        <i class="glyphicon glyphicon-warning-sign"></i>
                      Unparsable
                    </a>
                </li>


                <li class="">
                    <a href="dependency_report_kafka_clients_sb_sample.html">
                        <i class="glyphicon glyphicon-retweet"></i>
                      Dependencies
                    </a>
                </li>


                <li class="">
                    <a href="remotereport_kafka_clients_sb_sample.html">
                        <i class="glyphicon service-nav-logo"></i>
                      Remote Services
                    </a>
                </li>


                <li class="">
                    <a href="ignoredfiles_kafka_clients_sb_sample.html">
                        <i class="glyphicon glyphicon-eye-close"></i>
                      Ignored Files
                    </a>
                </li>


                <li class="">
                    <a href="about_kafka_clients_sb_sample.html">
                        <i class="fa fa-question-circle"></i>
                      About
                    </a>
                </li>
    </ul>
    <ul class="nav navbar-nav navbar-right">
<li>
    <a href="#" class="feedback-nav-btn jiraFeedbackTrigger"><i class="glyphicon glyphicon-comment"></i> Send Feedback </a>
</li>


    <script type="text/javascript" src="https://issues.redhat.com/s/f215932e68571747ac58d0f5d554396f-T/en_US-r7luaf/6346/82/1.4.16/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector.js?locale=en-US&amp;collectorId=8b9e338b"></script>

    <script type="text/javascript">

    var FEEDBACK_JS_ADDED = false;
    var FEEDBACK_FORM_TRIGGER = null;

    function displayFeedbackForm() {
        FEEDBACK_FORM_TRIGGER();
    }

    window.ATL_JQ_PAGE_PROPS = {
        "triggerFunction": function(showCollectorDialog) {
            FEEDBACK_FORM_TRIGGER = showCollectorDialog;
        }
    };

    document.addEventListener("DOMContentLoaded", function(event) {
            jQuery(".jiraFeedbackTrigger").click(function(e) {
                e.preventDefault();
                displayFeedbackForm();
            });
    });
    </script>
    </ul>
                </div><!-- /.nav-collapse -->
    </div>


    <div class="container-fluid" role="main">
        <div class="row">
            <div class="page-header page-header-no-border">
                <h1>
                    <div class="main">Source Report
                    <i class="glyphicon glyphicon-info-sign" data-toggle="tooltip" data-placement=right title="This report displays what Tackle Analysis found in individual files. Each item is shown below the line it was found on, and next to it, you may find a link to the rule which it was found by."></i></div>

                        <div class="path project-specific" data-project-id="4423800">
                            kafka-clients-sb-sample.jar/BOOT-INF/lib/netty-common-4.1.51.Final.jar/io/netty/util/concurrent/SingleThreadEventExecutor.java
                        </div>
                </h1>
            </div>
        </div>

        <div class="row">
            <div class="container-fluid theme-showcase" role="main">

                <div class="panel panel-primary">
                    <div class="panel-heading">
                        <h3 class="panel-title">Information</h3>
                    </div>
                    <div class="panel-body" style="overflow: auto;">

                        <!--<div style="height: 120pt; float:left;"></div> Keeps the minimal height. -->
                        <div class="points" style="text-align: center; color: #00254b; padding-bottom: 1ex;">
                            <div class="number">0</div>
                            <div>Story Points</div>
                        </div>

                        <div class="info" style="margin-left: 95pt;">


                                <h4>Technologies</h4>
                                <div class="technologies" style="overflow: auto"><!-- "auto" to contain all the tags. -->
                                        <span class="label label-info" title="INFORMATIONAL">Decompiled Java File</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                </div>

                                <ul class="classifications">
                                            <li>
                                                <div class="title">
                                                    <em>Threads</em>
<a title='View Rule: javase-01000' href='windup_ruleproviders.html#javase-01000'><span class='glyphicon glyphicon-link rule-link'></span></a>                                                </div>
                                                <div class="desc">The application uses Thread APIs.</div>
                                            </li>
                                </ul>


                            <div style="clear: both;"/><!-- Snaps under the height keeper. Yes, the same effect could be achieved by a table. -->
                        </div><!-- .info -->
                    </div>
                </div>



                <pre id="source">
package io.netty.util.concurrent;

import io.netty.util.concurrent.AbstractEventExecutor.LazyRunnable;
import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.PlatformDependent;
import io.netty.util.internal.SystemPropertyUtil;
import io.netty.util.internal.ThreadExecutorMap;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;
import java.lang.Thread.State;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor {
   static final int DEFAULT_MAX_PENDING_EXECUTOR_TASKS = Math.max(16, SystemPropertyUtil.getInt(&quot;io.netty.eventexecutor.maxPendingTasks&quot;, Integer.MAX_VALUE));
   private static final InternalLogger logger = InternalLoggerFactory.getInstance(SingleThreadEventExecutor.class);
   private static final int ST_NOT_STARTED = 1;
   private static final int ST_STARTED = 2;
   private static final int ST_SHUTTING_DOWN = 3;
   private static final int ST_SHUTDOWN = 4;
   private static final int ST_TERMINATED = 5;
   private static final Runnable NOOP_TASK = new Runnable() {
      public void run() {
      }
   };
   private static final AtomicIntegerFieldUpdater&lt;SingleThreadEventExecutor&gt; STATE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(SingleThreadEventExecutor.class, &quot;state&quot;);
   private static final AtomicReferenceFieldUpdater&lt;SingleThreadEventExecutor, ThreadProperties&gt; PROPERTIES_UPDATER = AtomicReferenceFieldUpdater.newUpdater(SingleThreadEventExecutor.class, ThreadProperties.class, &quot;threadProperties&quot;);
   private final Queue&lt;Runnable&gt; taskQueue;
   private volatile Thread thread;
   private volatile ThreadProperties threadProperties;
   private final Executor executor;
   private volatile boolean interrupted;
   private final CountDownLatch threadLock;
   private final Set&lt;Runnable&gt; shutdownHooks;
   private final boolean addTaskWakesUp;
   private final int maxPendingTasks;
   private final RejectedExecutionHandler rejectedExecutionHandler;
   private long lastExecutionTime;
   private volatile int state;
   private volatile long gracefulShutdownQuietPeriod;
   private volatile long gracefulShutdownTimeout;
   private long gracefulShutdownStartTime;
   private final Promise&lt;?&gt; terminationFuture;
   private static final long SCHEDULE_PURGE_INTERVAL;

   protected SingleThreadEventExecutor(EventExecutorGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp) {
      this(parent, (Executor)(new ThreadPerTaskExecutor(threadFactory)), addTaskWakesUp);
   }

   protected SingleThreadEventExecutor(EventExecutorGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp, int maxPendingTasks, RejectedExecutionHandler rejectedHandler) {
      this(parent, (Executor)(new ThreadPerTaskExecutor(threadFactory)), addTaskWakesUp, maxPendingTasks, rejectedHandler);
   }

   protected SingleThreadEventExecutor(EventExecutorGroup parent, Executor executor, boolean addTaskWakesUp) {
      this(parent, executor, addTaskWakesUp, DEFAULT_MAX_PENDING_EXECUTOR_TASKS, RejectedExecutionHandlers.reject());
   }

   protected SingleThreadEventExecutor(EventExecutorGroup parent, Executor executor, boolean addTaskWakesUp, int maxPendingTasks, RejectedExecutionHandler rejectedHandler) {
      super(parent);
      this.threadLock = new CountDownLatch(1);
      this.shutdownHooks = new LinkedHashSet();
      this.state = 1;
      this.terminationFuture = new DefaultPromise(GlobalEventExecutor.INSTANCE);
      this.addTaskWakesUp = addTaskWakesUp;
      this.maxPendingTasks = Math.max(16, maxPendingTasks);
      this.executor = ThreadExecutorMap.apply(executor, this);
      this.taskQueue = this.newTaskQueue(this.maxPendingTasks);
      this.rejectedExecutionHandler = (RejectedExecutionHandler)ObjectUtil.checkNotNull(rejectedHandler, &quot;rejectedHandler&quot;);
   }

   protected SingleThreadEventExecutor(EventExecutorGroup parent, Executor executor, boolean addTaskWakesUp, Queue&lt;Runnable&gt; taskQueue, RejectedExecutionHandler rejectedHandler) {
      super(parent);
      this.threadLock = new CountDownLatch(1);
      this.shutdownHooks = new LinkedHashSet();
      this.state = 1;
      this.terminationFuture = new DefaultPromise(GlobalEventExecutor.INSTANCE);
      this.addTaskWakesUp = addTaskWakesUp;
      this.maxPendingTasks = DEFAULT_MAX_PENDING_EXECUTOR_TASKS;
      this.executor = ThreadExecutorMap.apply(executor, this);
      this.taskQueue = (Queue)ObjectUtil.checkNotNull(taskQueue, &quot;taskQueue&quot;);
      this.rejectedExecutionHandler = (RejectedExecutionHandler)ObjectUtil.checkNotNull(rejectedHandler, &quot;rejectedHandler&quot;);
   }

   /** @deprecated */
   @Deprecated
   protected Queue&lt;Runnable&gt; newTaskQueue() {
      return this.newTaskQueue(this.maxPendingTasks);
   }

   protected Queue&lt;Runnable&gt; newTaskQueue(int maxPendingTasks) {
      return new LinkedBlockingQueue(maxPendingTasks);
   }

   protected void interruptThread() {
      Thread currentThread = this.thread;
      if (currentThread == null) {
         this.interrupted = true;
      } else {
         currentThread.interrupt();
      }

   }

   protected Runnable pollTask() {
      assert this.inEventLoop();

      return pollTaskFrom(this.taskQueue);
   }

   protected static Runnable pollTaskFrom(Queue&lt;Runnable&gt; taskQueue) {
      Runnable task;
      do {
         task = (Runnable)taskQueue.poll();
      } while(task == WAKEUP_TASK);

      return task;
   }

   protected Runnable takeTask() {
      assert this.inEventLoop();

      if (!(this.taskQueue instanceof BlockingQueue)) {
         throw new UnsupportedOperationException();
      } else {
         BlockingQueue taskQueue = (BlockingQueue)this.taskQueue;

         Runnable task;
         do {
            ScheduledFutureTask&lt;?&gt; scheduledTask = this.peekScheduledTask();
            if (scheduledTask == null) {
               Runnable task = null;

               try {
                  task = (Runnable)taskQueue.take();
                  if (task == WAKEUP_TASK) {
                     task = null;
                  }
               } catch (InterruptedException var7) {
                  ;
               }

               return task;
            }

            long delayNanos = scheduledTask.delayNanos();
            task = null;
            if (delayNanos &gt; 0L) {
               try {
                  task = (Runnable)taskQueue.poll(delayNanos, TimeUnit.NANOSECONDS);
               } catch (InterruptedException var8) {
                  return null;
               }
            }

            if (task == null) {
               this.fetchFromScheduledTaskQueue();
               task = (Runnable)taskQueue.poll();
            }
         } while(task == null);

         return task;
      }
   }

   private boolean fetchFromScheduledTaskQueue() {
      if (this.scheduledTaskQueue != null &amp;&amp; !this.scheduledTaskQueue.isEmpty()) {
         long nanoTime = AbstractScheduledEventExecutor.nanoTime();

         Runnable scheduledTask;
         do {
            scheduledTask = this.pollScheduledTask(nanoTime);
            if (scheduledTask == null) {
               return true;
            }
         } while(this.taskQueue.offer(scheduledTask));

         this.scheduledTaskQueue.add((ScheduledFutureTask)scheduledTask);
         return false;
      } else {
         return true;
      }
   }

   private boolean executeExpiredScheduledTasks() {
      if (this.scheduledTaskQueue != null &amp;&amp; !this.scheduledTaskQueue.isEmpty()) {
         long nanoTime = AbstractScheduledEventExecutor.nanoTime();
         Runnable scheduledTask = this.pollScheduledTask(nanoTime);
         if (scheduledTask == null) {
            return false;
         } else {
            do {
               safeExecute(scheduledTask);
            } while((scheduledTask = this.pollScheduledTask(nanoTime)) != null);

            return true;
         }
      } else {
         return false;
      }
   }

   protected Runnable peekTask() {
      assert this.inEventLoop();

      return (Runnable)this.taskQueue.peek();
   }

   protected boolean hasTasks() {
      assert this.inEventLoop();

      return !this.taskQueue.isEmpty();
   }

   public int pendingTasks() {
      return this.taskQueue.size();
   }

   protected void addTask(Runnable task) {
      ObjectUtil.checkNotNull(task, &quot;task&quot;);
      if (!this.offerTask(task)) {
         this.reject(task);
      }

   }

   final boolean offerTask(Runnable task) {
      if (this.isShutdown()) {
         reject();
      }

      return this.taskQueue.offer(task);
   }

   protected boolean removeTask(Runnable task) {
      return this.taskQueue.remove(ObjectUtil.checkNotNull(task, &quot;task&quot;));
   }

   protected boolean runAllTasks() {
      assert this.inEventLoop();

      boolean ranAtLeastOne = false;

      boolean fetchedAll;
      do {
         fetchedAll = this.fetchFromScheduledTaskQueue();
         if (this.runAllTasksFrom(this.taskQueue)) {
            ranAtLeastOne = true;
         }
      } while(!fetchedAll);

      if (ranAtLeastOne) {
         this.lastExecutionTime = ScheduledFutureTask.nanoTime();
      }

      this.afterRunningAllTasks();
      return ranAtLeastOne;
   }

   protected final boolean runScheduledAndExecutorTasks(int maxDrainAttempts) {
      assert this.inEventLoop();

      int drainAttempt = 0;

      do {
         boolean ranAtLeastOneTask = this.runExistingTasksFrom(this.taskQueue) | this.executeExpiredScheduledTasks();
         if (!ranAtLeastOneTask) {
            break;
         }

         ++drainAttempt;
      } while(drainAttempt &lt; maxDrainAttempts);

      if (drainAttempt &gt; 0) {
         this.lastExecutionTime = ScheduledFutureTask.nanoTime();
      }

      this.afterRunningAllTasks();
      return drainAttempt &gt; 0;
   }

   protected final boolean runAllTasksFrom(Queue&lt;Runnable&gt; taskQueue) {
      Runnable task = pollTaskFrom(taskQueue);
      if (task == null) {
         return false;
      } else {
         do {
            safeExecute(task);
            task = pollTaskFrom(taskQueue);
         } while(task != null);

         return true;
      }
   }

   private boolean runExistingTasksFrom(Queue&lt;Runnable&gt; taskQueue) {
      Runnable task = pollTaskFrom(taskQueue);
      if (task == null) {
         return false;
      } else {
         int remaining = Math.min(this.maxPendingTasks, taskQueue.size());
         safeExecute(task);

         while(remaining-- &gt; 0 &amp;&amp; (task = (Runnable)taskQueue.poll()) != null) {
            safeExecute(task);
         }

         return true;
      }
   }

   protected boolean runAllTasks(long timeoutNanos) {
      this.fetchFromScheduledTaskQueue();
      Runnable task = this.pollTask();
      if (task == null) {
         this.afterRunningAllTasks();
         return false;
      } else {
         long deadline = timeoutNanos &gt; 0L ? ScheduledFutureTask.nanoTime() + timeoutNanos : 0L;
         long runTasks = 0L;

         long lastExecutionTime;
         while(true) {
            safeExecute(task);
            ++runTasks;
            if ((runTasks &amp; 63L) == 0L) {
               lastExecutionTime = ScheduledFutureTask.nanoTime();
               if (lastExecutionTime &gt;= deadline) {
                  break;
               }
            }

            task = this.pollTask();
            if (task == null) {
               lastExecutionTime = ScheduledFutureTask.nanoTime();
               break;
            }
         }

         this.afterRunningAllTasks();
         this.lastExecutionTime = lastExecutionTime;
         return true;
      }
   }

   protected void afterRunningAllTasks() {
   }

   protected long delayNanos(long currentTimeNanos) {
      ScheduledFutureTask&lt;?&gt; scheduledTask = this.peekScheduledTask();
      return scheduledTask == null ? SCHEDULE_PURGE_INTERVAL : scheduledTask.delayNanos(currentTimeNanos);
   }

   protected long deadlineNanos() {
      ScheduledFutureTask&lt;?&gt; scheduledTask = this.peekScheduledTask();
      return scheduledTask == null ? nanoTime() + SCHEDULE_PURGE_INTERVAL : scheduledTask.deadlineNanos();
   }

   protected void updateLastExecutionTime() {
      this.lastExecutionTime = ScheduledFutureTask.nanoTime();
   }

   protected abstract void run();

   protected void cleanup() {
   }

   protected void wakeup(boolean inEventLoop) {
      if (!inEventLoop) {
         this.taskQueue.offer(WAKEUP_TASK);
      }

   }

   public boolean inEventLoop(Thread thread) {
      return thread == this.thread;
   }

   public void addShutdownHook(final Runnable task) {
      if (this.inEventLoop()) {
         this.shutdownHooks.add(task);
      } else {
         this.execute(new Runnable() {
            public void run() {
               SingleThreadEventExecutor.this.shutdownHooks.add(task);
            }
         });
      }

   }

   public void removeShutdownHook(final Runnable task) {
      if (this.inEventLoop()) {
         this.shutdownHooks.remove(task);
      } else {
         this.execute(new Runnable() {
            public void run() {
               SingleThreadEventExecutor.this.shutdownHooks.remove(task);
            }
         });
      }

   }

   private boolean runShutdownHooks() {
      boolean ran = false;

      while(!this.shutdownHooks.isEmpty()) {
         List&lt;Runnable&gt; copy = new ArrayList(this.shutdownHooks);
         this.shutdownHooks.clear();
         Iterator var3 = copy.iterator();

         while(var3.hasNext()) {
            Runnable task = (Runnable)var3.next();

            try {
               task.run();
            } catch (Throwable var9) {
               logger.warn(&quot;Shutdown hook raised an exception.&quot;, var9);
            } finally {
               ran = true;
            }
         }
      }

      if (ran) {
         this.lastExecutionTime = ScheduledFutureTask.nanoTime();
      }

      return ran;
   }

   public Future&lt;?&gt; shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {
      ObjectUtil.checkPositiveOrZero(quietPeriod, &quot;quietPeriod&quot;);
      if (timeout &lt; quietPeriod) {
         throw new IllegalArgumentException(&quot;timeout: &quot; + timeout + &quot; (expected &gt;= quietPeriod (&quot; + quietPeriod + &quot;))&quot;);
      } else {
         ObjectUtil.checkNotNull(unit, &quot;unit&quot;);
         if (this.isShuttingDown()) {
            return this.terminationFuture();
         } else {
            boolean inEventLoop = this.inEventLoop();

            boolean wakeup;
            int oldState;
            int newState;
            do {
               if (this.isShuttingDown()) {
                  return this.terminationFuture();
               }

               wakeup = true;
               oldState = this.state;
               if (inEventLoop) {
                  newState = 3;
               } else {
                  switch(oldState) {
                  case 1:
                  case 2:
                     newState = 3;
                     break;
                  default:
                     newState = oldState;
                     wakeup = false;
                  }
               }
            } while(!STATE_UPDATER.compareAndSet(this, oldState, newState));

            this.gracefulShutdownQuietPeriod = unit.toNanos(quietPeriod);
            this.gracefulShutdownTimeout = unit.toNanos(timeout);
            if (this.ensureThreadStarted(oldState)) {
               return this.terminationFuture;
            } else {
               if (wakeup) {
                  this.taskQueue.offer(WAKEUP_TASK);
                  if (!this.addTaskWakesUp) {
                     this.wakeup(inEventLoop);
                  }
               }

               return this.terminationFuture();
            }
         }
      }
   }

   public Future&lt;?&gt; terminationFuture() {
      return this.terminationFuture;
   }

   /** @deprecated */
   @Deprecated
   public void shutdown() {
      if (!this.isShutdown()) {
         boolean inEventLoop = this.inEventLoop();

         boolean wakeup;
         int oldState;
         int newState;
         do {
            if (this.isShuttingDown()) {
               return;
            }

            wakeup = true;
            oldState = this.state;
            if (inEventLoop) {
               newState = 4;
            } else {
               switch(oldState) {
               case 1:
               case 2:
               case 3:
                  newState = 4;
                  break;
               default:
                  newState = oldState;
                  wakeup = false;
               }
            }
         } while(!STATE_UPDATER.compareAndSet(this, oldState, newState));

         if (!this.ensureThreadStarted(oldState)) {
            if (wakeup) {
               this.taskQueue.offer(WAKEUP_TASK);
               if (!this.addTaskWakesUp) {
                  this.wakeup(inEventLoop);
               }
            }

         }
      }
   }

   public boolean isShuttingDown() {
      return this.state &gt;= 3;
   }

   public boolean isShutdown() {
      return this.state &gt;= 4;
   }

   public boolean isTerminated() {
      return this.state == 5;
   }

   protected boolean confirmShutdown() {
      if (!this.isShuttingDown()) {
         return false;
      } else if (!this.inEventLoop()) {
         throw new IllegalStateException(&quot;must be invoked from an event loop&quot;);
      } else {
         this.cancelScheduledTasks();
         if (this.gracefulShutdownStartTime == 0L) {
            this.gracefulShutdownStartTime = ScheduledFutureTask.nanoTime();
         }

         if (!this.runAllTasks() &amp;&amp; !this.runShutdownHooks()) {
            long nanoTime = ScheduledFutureTask.nanoTime();
            if (!this.isShutdown() &amp;&amp; nanoTime - this.gracefulShutdownStartTime &lt;= this.gracefulShutdownTimeout) {
               if (nanoTime - this.lastExecutionTime &lt;= this.gracefulShutdownQuietPeriod) {
                  this.taskQueue.offer(WAKEUP_TASK);

                  try {
                     Thread.sleep(100L);
                  } catch (InterruptedException var4) {
                     ;
                  }

                  return false;
               } else {
                  return true;
               }
            } else {
               return true;
            }
         } else if (this.isShutdown()) {
            return true;
         } else if (this.gracefulShutdownQuietPeriod == 0L) {
            return true;
         } else {
            this.taskQueue.offer(WAKEUP_TASK);
            return false;
         }
      }
   }

   public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
      ObjectUtil.checkNotNull(unit, &quot;unit&quot;);
      if (this.inEventLoop()) {
         throw new IllegalStateException(&quot;cannot await termination of the current thread&quot;);
      } else {
         this.threadLock.await(timeout, unit);
         return this.isTerminated();
      }
   }

   public void execute(Runnable task) {
      ObjectUtil.checkNotNull(task, &quot;task&quot;);
      this.execute(task, !(task instanceof LazyRunnable) &amp;&amp; this.wakesUpForTask(task));
   }

   public void lazyExecute(Runnable task) {
      this.execute((Runnable)ObjectUtil.checkNotNull(task, &quot;task&quot;), false);
   }

   private void execute(Runnable task, boolean immediate) {
      boolean inEventLoop = this.inEventLoop();
      this.addTask(task);
      if (!inEventLoop) {
         this.startThread();
         if (this.isShutdown()) {
            boolean reject = false;

            try {
               if (this.removeTask(task)) {
                  reject = true;
               }
            } catch (UnsupportedOperationException var6) {
               ;
            }

            if (reject) {
               reject();
            }
         }
      }

      if (!this.addTaskWakesUp &amp;&amp; immediate) {
         this.wakeup(inEventLoop);
      }

   }

   public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException {
      this.throwIfInEventLoop(&quot;invokeAny&quot;);
      return super.invokeAny(tasks);
   }

   public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
      this.throwIfInEventLoop(&quot;invokeAny&quot;);
      return super.invokeAny(tasks, timeout, unit);
   }

   public &lt;T&gt; List&lt;java.util.concurrent.Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException {
      this.throwIfInEventLoop(&quot;invokeAll&quot;);
      return super.invokeAll(tasks);
   }

   public &lt;T&gt; List&lt;java.util.concurrent.Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException {
      this.throwIfInEventLoop(&quot;invokeAll&quot;);
      return super.invokeAll(tasks, timeout, unit);
   }

   private void throwIfInEventLoop(String method) {
      if (this.inEventLoop()) {
         throw new RejectedExecutionException(&quot;Calling &quot; + method + &quot; from within the EventLoop is not allowed&quot;);
      }
   }

   public final ThreadProperties threadProperties() {
      ThreadProperties threadProperties = this.threadProperties;
      if (threadProperties == null) {
         Thread thread = this.thread;
         if (thread == null) {
            assert !this.inEventLoop();

            this.submit(NOOP_TASK).syncUninterruptibly();
            thread = this.thread;

            assert thread != null;
         }

         threadProperties = new SingleThreadEventExecutor.DefaultThreadProperties(thread);
         if (!PROPERTIES_UPDATER.compareAndSet(this, (Object)null, threadProperties)) {
            threadProperties = this.threadProperties;
         }
      }

      return (ThreadProperties)threadProperties;
   }

   protected boolean wakesUpForTask(Runnable task) {
      return true;
   }

   protected static void reject() {
      throw new RejectedExecutionException(&quot;event executor terminated&quot;);
   }

   protected final void reject(Runnable task) {
      this.rejectedExecutionHandler.rejected(task, this);
   }

   private void startThread() {
      if (this.state == 1 &amp;&amp; STATE_UPDATER.compareAndSet(this, 1, 2)) {
         boolean success = false;

         try {
            this.doStartThread();
            success = true;
         } finally {
            if (!success) {
               STATE_UPDATER.compareAndSet(this, 2, 1);
            }

         }
      }

   }

   private boolean ensureThreadStarted(int oldState) {
      if (oldState == 1) {
         try {
            this.doStartThread();
         } catch (Throwable var3) {
            STATE_UPDATER.set(this, 5);
            this.terminationFuture.tryFailure(var3);
            if (!(var3 instanceof Exception)) {
               PlatformDependent.throwException(var3);
            }

            return true;
         }
      }

      return false;
   }

   private void doStartThread() {
      assert this.thread == null;

      this.executor.execute(new Runnable() {
         public void run() {
            SingleThreadEventExecutor.this.thread = Thread.currentThread();
            if (SingleThreadEventExecutor.this.interrupted) {
               SingleThreadEventExecutor.this.thread.interrupt();
            }

            boolean success = false;
            SingleThreadEventExecutor.this.updateLastExecutionTime();
            boolean var142 = false;

            int numUserTasksx;
            label2824: {
               try {
                  var142 = true;
                  SingleThreadEventExecutor.this.run();
                  success = true;
                  var142 = false;
                  break label2824;
               } catch (Throwable var152) {
                  SingleThreadEventExecutor.logger.warn(&quot;Unexpected exception from an event executor: &quot;, var152);
                  var142 = false;
               } finally {
                  if (var142) {
                     int numUserTasksxxxxxxxx;
                     do {
                        numUserTasksxxxxxxxx = SingleThreadEventExecutor.this.state;
                     } while(numUserTasksxxxxxxxx &lt; 3 &amp;&amp; !SingleThreadEventExecutor.STATE_UPDATER.compareAndSet(SingleThreadEventExecutor.this, numUserTasksxxxxxxxx, 3));

                     if (success &amp;&amp; SingleThreadEventExecutor.this.gracefulShutdownStartTime == 0L &amp;&amp; SingleThreadEventExecutor.logger.isErrorEnabled()) {
                        SingleThreadEventExecutor.logger.error(&quot;Buggy &quot; + EventExecutor.class.getSimpleName() + &quot; implementation; &quot; + SingleThreadEventExecutor.class.getSimpleName() + &quot;.confirmShutdown() must be called before run() implementation terminates.&quot;);
                     }

                     while(true) {
                        boolean var130 = false;

                        try {
                           var130 = true;
                           if (SingleThreadEventExecutor.this.confirmShutdown()) {
                              do {
                                 numUserTasksxxxxxxxx = SingleThreadEventExecutor.this.state;
                              } while(numUserTasksxxxxxxxx &lt; 4 &amp;&amp; !SingleThreadEventExecutor.STATE_UPDATER.compareAndSet(SingleThreadEventExecutor.this, numUserTasksxxxxxxxx, 4));

                              SingleThreadEventExecutor.this.confirmShutdown();
                              var130 = false;
                              break;
                           }
                        } finally {
                           if (var130) {
                              boolean var118 = false;

                              try {
                                 var118 = true;
                                 SingleThreadEventExecutor.this.cleanup();
                                 var118 = false;
                              } finally {
                                 if (var118) {
                                    FastThreadLocal.removeAll();
                                    SingleThreadEventExecutor.STATE_UPDATER.set(SingleThreadEventExecutor.this, 5);
                                    SingleThreadEventExecutor.this.threadLock.countDown();
                                    int numUserTasks = SingleThreadEventExecutor.this.drainTasks();
                                    if (numUserTasks &gt; 0 &amp;&amp; SingleThreadEventExecutor.logger.isWarnEnabled()) {
                                       SingleThreadEventExecutor.logger.warn(&quot;An event executor terminated with non-empty task queue (&quot; + numUserTasks + &#39;)&#39;);
                                    }

                                    SingleThreadEventExecutor.this.terminationFuture.setSuccess((Object)null);
                                 }
                              }

                              FastThreadLocal.removeAll();
                              SingleThreadEventExecutor.STATE_UPDATER.set(SingleThreadEventExecutor.this, 5);
                              SingleThreadEventExecutor.this.threadLock.countDown();
                              int numUserTasksxxxxxxxxxx = SingleThreadEventExecutor.this.drainTasks();
                              if (numUserTasksxxxxxxxxxx &gt; 0 &amp;&amp; SingleThreadEventExecutor.logger.isWarnEnabled()) {
                                 SingleThreadEventExecutor.logger.warn(&quot;An event executor terminated with non-empty task queue (&quot; + numUserTasksxxxxxxxxxx + &#39;)&#39;);
                              }

                              SingleThreadEventExecutor.this.terminationFuture.setSuccess((Object)null);
                           }
                        }
                     }

                     boolean var106 = false;

                     try {
                        var106 = true;
                        SingleThreadEventExecutor.this.cleanup();
                        var106 = false;
                     } finally {
                        if (var106) {
                           FastThreadLocal.removeAll();
                           SingleThreadEventExecutor.STATE_UPDATER.set(SingleThreadEventExecutor.this, 5);
                           SingleThreadEventExecutor.this.threadLock.countDown();
                           int numUserTasksxxxxxxxxx = SingleThreadEventExecutor.this.drainTasks();
                           if (numUserTasksxxxxxxxxx &gt; 0 &amp;&amp; SingleThreadEventExecutor.logger.isWarnEnabled()) {
                              SingleThreadEventExecutor.logger.warn(&quot;An event executor terminated with non-empty task queue (&quot; + numUserTasksxxxxxxxxx + &#39;)&#39;);
                           }

                           SingleThreadEventExecutor.this.terminationFuture.setSuccess((Object)null);
                        }
                     }

                     FastThreadLocal.removeAll();
                     SingleThreadEventExecutor.STATE_UPDATER.set(SingleThreadEventExecutor.this, 5);
                     SingleThreadEventExecutor.this.threadLock.countDown();
                     numUserTasksxxxxxxxx = SingleThreadEventExecutor.this.drainTasks();
                     if (numUserTasksxxxxxxxx &gt; 0 &amp;&amp; SingleThreadEventExecutor.logger.isWarnEnabled()) {
                        SingleThreadEventExecutor.logger.warn(&quot;An event executor terminated with non-empty task queue (&quot; + numUserTasksxxxxxxxx + &#39;)&#39;);
                     }

                     SingleThreadEventExecutor.this.terminationFuture.setSuccess((Object)null);
                  }
               }

               do {
                  numUserTasksx = SingleThreadEventExecutor.this.state;
               } while(numUserTasksx &lt; 3 &amp;&amp; !SingleThreadEventExecutor.STATE_UPDATER.compareAndSet(SingleThreadEventExecutor.this, numUserTasksx, 3));

               if (success &amp;&amp; SingleThreadEventExecutor.this.gracefulShutdownStartTime == 0L &amp;&amp; SingleThreadEventExecutor.logger.isErrorEnabled()) {
                  SingleThreadEventExecutor.logger.error(&quot;Buggy &quot; + EventExecutor.class.getSimpleName() + &quot; implementation; &quot; + SingleThreadEventExecutor.class.getSimpleName() + &quot;.confirmShutdown() must be called before run() implementation terminates.&quot;);
               }

               while(true) {
                  boolean var94 = false;

                  try {
                     var94 = true;
                     if (SingleThreadEventExecutor.this.confirmShutdown()) {
                        do {
                           numUserTasksx = SingleThreadEventExecutor.this.state;
                        } while(numUserTasksx &lt; 4 &amp;&amp; !SingleThreadEventExecutor.STATE_UPDATER.compareAndSet(SingleThreadEventExecutor.this, numUserTasksx, 4));

                        SingleThreadEventExecutor.this.confirmShutdown();
                        var94 = false;
                        break;
                     }
                  } finally {
                     if (var94) {
                        boolean var82 = false;

                        try {
                           var82 = true;
                           SingleThreadEventExecutor.this.cleanup();
                           var82 = false;
                        } finally {
                           if (var82) {
                              FastThreadLocal.removeAll();
                              SingleThreadEventExecutor.STATE_UPDATER.set(SingleThreadEventExecutor.this, 5);
                              SingleThreadEventExecutor.this.threadLock.countDown();
                              int numUserTasksxxxxxxx = SingleThreadEventExecutor.this.drainTasks();
                              if (numUserTasksxxxxxxx &gt; 0 &amp;&amp; SingleThreadEventExecutor.logger.isWarnEnabled()) {
                                 SingleThreadEventExecutor.logger.warn(&quot;An event executor terminated with non-empty task queue (&quot; + numUserTasksxxxxxxx + &#39;)&#39;);
                              }

                              SingleThreadEventExecutor.this.terminationFuture.setSuccess((Object)null);
                           }
                        }

                        FastThreadLocal.removeAll();
                        SingleThreadEventExecutor.STATE_UPDATER.set(SingleThreadEventExecutor.this, 5);
                        SingleThreadEventExecutor.this.threadLock.countDown();
                        int numUserTasksxxxxxx = SingleThreadEventExecutor.this.drainTasks();
                        if (numUserTasksxxxxxx &gt; 0 &amp;&amp; SingleThreadEventExecutor.logger.isWarnEnabled()) {
                           SingleThreadEventExecutor.logger.warn(&quot;An event executor terminated with non-empty task queue (&quot; + numUserTasksxxxxxx + &#39;)&#39;);
                        }

                        SingleThreadEventExecutor.this.terminationFuture.setSuccess((Object)null);
                     }
                  }
               }

               boolean var70 = false;

               try {
                  var70 = true;
                  SingleThreadEventExecutor.this.cleanup();
                  var70 = false;
               } finally {
                  if (var70) {
                     FastThreadLocal.removeAll();
                     SingleThreadEventExecutor.STATE_UPDATER.set(SingleThreadEventExecutor.this, 5);
                     SingleThreadEventExecutor.this.threadLock.countDown();
                     int numUserTasksxxxxx = SingleThreadEventExecutor.this.drainTasks();
                     if (numUserTasksxxxxx &gt; 0 &amp;&amp; SingleThreadEventExecutor.logger.isWarnEnabled()) {
                        SingleThreadEventExecutor.logger.warn(&quot;An event executor terminated with non-empty task queue (&quot; + numUserTasksxxxxx + &#39;)&#39;);
                     }

                     SingleThreadEventExecutor.this.terminationFuture.setSuccess((Object)null);
                  }
               }

               FastThreadLocal.removeAll();
               SingleThreadEventExecutor.STATE_UPDATER.set(SingleThreadEventExecutor.this, 5);
               SingleThreadEventExecutor.this.threadLock.countDown();
               numUserTasksx = SingleThreadEventExecutor.this.drainTasks();
               if (numUserTasksx &gt; 0 &amp;&amp; SingleThreadEventExecutor.logger.isWarnEnabled()) {
                  SingleThreadEventExecutor.logger.warn(&quot;An event executor terminated with non-empty task queue (&quot; + numUserTasksx + &#39;)&#39;);
               }

               SingleThreadEventExecutor.this.terminationFuture.setSuccess((Object)null);
               return;
            }

            do {
               numUserTasksx = SingleThreadEventExecutor.this.state;
            } while(numUserTasksx &lt; 3 &amp;&amp; !SingleThreadEventExecutor.STATE_UPDATER.compareAndSet(SingleThreadEventExecutor.this, numUserTasksx, 3));

            if (success &amp;&amp; SingleThreadEventExecutor.this.gracefulShutdownStartTime == 0L &amp;&amp; SingleThreadEventExecutor.logger.isErrorEnabled()) {
               SingleThreadEventExecutor.logger.error(&quot;Buggy &quot; + EventExecutor.class.getSimpleName() + &quot; implementation; &quot; + SingleThreadEventExecutor.class.getSimpleName() + &quot;.confirmShutdown() must be called before run() implementation terminates.&quot;);
            }

            while(true) {
               boolean var58 = false;

               try {
                  var58 = true;
                  if (SingleThreadEventExecutor.this.confirmShutdown()) {
                     do {
                        numUserTasksx = SingleThreadEventExecutor.this.state;
                     } while(numUserTasksx &lt; 4 &amp;&amp; !SingleThreadEventExecutor.STATE_UPDATER.compareAndSet(SingleThreadEventExecutor.this, numUserTasksx, 4));

                     SingleThreadEventExecutor.this.confirmShutdown();
                     var58 = false;
                     break;
                  }
               } finally {
                  if (var58) {
                     boolean var46 = false;

                     try {
                        var46 = true;
                        SingleThreadEventExecutor.this.cleanup();
                        var46 = false;
                     } finally {
                        if (var46) {
                           FastThreadLocal.removeAll();
                           SingleThreadEventExecutor.STATE_UPDATER.set(SingleThreadEventExecutor.this, 5);
                           SingleThreadEventExecutor.this.threadLock.countDown();
                           int numUserTasksxxxx = SingleThreadEventExecutor.this.drainTasks();
                           if (numUserTasksxxxx &gt; 0 &amp;&amp; SingleThreadEventExecutor.logger.isWarnEnabled()) {
                              SingleThreadEventExecutor.logger.warn(&quot;An event executor terminated with non-empty task queue (&quot; + numUserTasksxxxx + &#39;)&#39;);
                           }

                           SingleThreadEventExecutor.this.terminationFuture.setSuccess((Object)null);
                        }
                     }

                     FastThreadLocal.removeAll();
                     SingleThreadEventExecutor.STATE_UPDATER.set(SingleThreadEventExecutor.this, 5);
                     SingleThreadEventExecutor.this.threadLock.countDown();
                     int numUserTasksxxx = SingleThreadEventExecutor.this.drainTasks();
                     if (numUserTasksxxx &gt; 0 &amp;&amp; SingleThreadEventExecutor.logger.isWarnEnabled()) {
                        SingleThreadEventExecutor.logger.warn(&quot;An event executor terminated with non-empty task queue (&quot; + numUserTasksxxx + &#39;)&#39;);
                     }

                     SingleThreadEventExecutor.this.terminationFuture.setSuccess((Object)null);
                  }
               }
            }

            boolean var34 = false;

            try {
               var34 = true;
               SingleThreadEventExecutor.this.cleanup();
               var34 = false;
            } finally {
               if (var34) {
                  FastThreadLocal.removeAll();
                  SingleThreadEventExecutor.STATE_UPDATER.set(SingleThreadEventExecutor.this, 5);
                  SingleThreadEventExecutor.this.threadLock.countDown();
                  int numUserTasksxx = SingleThreadEventExecutor.this.drainTasks();
                  if (numUserTasksxx &gt; 0 &amp;&amp; SingleThreadEventExecutor.logger.isWarnEnabled()) {
                     SingleThreadEventExecutor.logger.warn(&quot;An event executor terminated with non-empty task queue (&quot; + numUserTasksxx + &#39;)&#39;);
                  }

                  SingleThreadEventExecutor.this.terminationFuture.setSuccess((Object)null);
               }
            }

            FastThreadLocal.removeAll();
            SingleThreadEventExecutor.STATE_UPDATER.set(SingleThreadEventExecutor.this, 5);
            SingleThreadEventExecutor.this.threadLock.countDown();
            numUserTasksx = SingleThreadEventExecutor.this.drainTasks();
            if (numUserTasksx &gt; 0 &amp;&amp; SingleThreadEventExecutor.logger.isWarnEnabled()) {
               SingleThreadEventExecutor.logger.warn(&quot;An event executor terminated with non-empty task queue (&quot; + numUserTasksx + &#39;)&#39;);
            }

            SingleThreadEventExecutor.this.terminationFuture.setSuccess((Object)null);
         }
      });
   }

   final int drainTasks() {
      int numTasks = 0;

      while(true) {
         Runnable runnable = (Runnable)this.taskQueue.poll();
         if (runnable == null) {
            return numTasks;
         }

         if (WAKEUP_TASK != runnable) {
            ++numTasks;
         }
      }
   }

   static {
      SCHEDULE_PURGE_INTERVAL = TimeUnit.SECONDS.toNanos(1L);
   }

   private static final class DefaultThreadProperties implements ThreadProperties {
      private final Thread t;

      DefaultThreadProperties(Thread t) {
         this.t = t;
      }

      public State state() {
         return this.t.getState();
      }

      public int priority() {
         return this.t.getPriority();
      }

      public boolean isInterrupted() {
         return this.t.isInterrupted();
      }

      public boolean isDaemon() {
         return this.t.isDaemon();
      }

      public String name() {
         return this.t.getName();
      }

      public long id() {
         return this.t.getId();
      }

      public StackTraceElement[] stackTrace() {
         return this.t.getStackTrace();
      }

      public boolean isAlive() {
         return this.t.isAlive();
      }
   }

   /** @deprecated */
   @Deprecated
   protected interface NonWakeupRunnable extends LazyRunnable {
   }
}
</pre>
            </div> <!-- /container -->
        </div><!-- /row-->
    </div><!-- /container main-->


<div style="text-align: left; font-size: small; color: gray; font-style: italic;">Page generated: Feb 15, 2023, 10:00:29 PM</div>

    <script src="resources/js/jquery-migrate-1.4.1.min.js"></script>
    <script src="resources/js/bootstrap.min.js"></script>

    <script type="text/javascript" src="resources/libraries/jquery-ui/jquery.ui.widget.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.min.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.java-properties.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.java-manifest.js"></script>
    <script type="text/javascript" src="resources/libraries/sausage/jquery.sausage.min.js"></script>

    <script type="text/javascript">
        var script   = document.createElement("script");
        script.type  = "text/javascript";
            script.src   = "resources/js/navbar.js";
        document.body.appendChild(script);
    </script>

    <script type="text/javascript">
        $(window).on("hashchange", function () {
            window.scrollTo(window.scrollX, window.scrollY - 50);
        });
        function offsetAnchor() {
            if(location.hash.length !== 0) {
                window.scrollTo(window.scrollX, window.scrollY - 50);
            }
        }
        window.setTimeout(function() {
            offsetAnchor();
        }, 1);
        $(document).ready(function(){
            $("pre").snippet("java",{style:"ide-eclipse", showNum:true,boxFill:"#ffeeb9", box: "" });



            if (location.hash) {
                var atag = $("a[name='" + location.hash.substr(1)  +  "']");
                $('html,body').animate({scrollTop: atag.offset().top - 150},'slow');
            }

            $('code[class]').each(function(){
                 var codeSyntax = ($(this).attr('class'));
                 if(codeSyntax) {
                    $(this).parent().snippet(codeSyntax,{style:'ide-eclipse', menu:false, showNum:false});
                 }
            });
            $(window).sausage({ page: 'li.box' });
            $(window).resize(function () {
                $('div.sausage-set').css('top', parseInt($('#main-navbar').css("height")));
            });

            // Deprecated
            // $(window).load(function () {
            //     $('div.sausage-set').css('top', parseInt($('#main-navbar').css("height")));
            // });
            $(window).on('load', function () {
                $('div.sausage-set').css('top', parseInt($('#main-navbar').css("height")));
            });
        });

        function qs(key) {
            key = key.replace(/[*+?^$.\[\]{}()|\\\/]/g, "\\$&"); // escape RegEx meta chars
            var match = location.search.match(new RegExp("[?&]"+key+"=([^&]+)(&|$)"));
            return match && decodeURIComponent(match[1].replace(/\+/g, " "));
        }

        $(document).ready(function() {
            var defaultProjectID = 4423800;
            var selectedProject = qs("project");
            if (!selectedProject)
                selectedProject = defaultProjectID;

            $(".project-specific").each(function(index, element) {
                var currentProject = $(element).data("project-id");

                if (currentProject == selectedProject)
                    $(element).show();
                else
                    $(element).remove();
            });
            $("#main-navbar").show();
        });
    </script>
    <script>$(document).ready(function(){$('[data-toggle="tooltip"]').tooltip();});</script>
</body>
</html>
