<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <title>Source Report for Recycler.java</title>
    <link href="resources/css/bootstrap.min.css" rel="stylesheet"/>
    <link href="resources/css/font-awesome.min.css" rel="stylesheet" />
    <link href="resources/css/windup.css" rel="stylesheet" media="screen"/>
    <link rel="stylesheet" type="text/css" href="resources/libraries/snippet/jquery.snippet.min.css" />
    <link rel="stylesheet" type="text/css" href="resources/css/windup-source.css" />
    <link rel="stylesheet" type="text/css" href="resources/libraries/sausage/sausage.css" />

<link href="resources/img/WINDUP/favicon.png" rel="shortcut icon" type="image/x-icon"/>
    <script src="resources/js/jquery-3.3.1.min.js"></script>
</head>
<body role="document" class="source-report">

    <div class="navbar navbar-inverse navbar-fixed-top" id="main-navbar" style="display: none">
        <div class="wu-navbar-header navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <span class="wu-navbar-header">
<strong class="wu-navbar-header">Windup</strong>
<img align="right" class="wu-navbar-header" src="resources/img/WINDUP/brand-horizontal.png" />            </span>        </div>


                <div class="navbar-collapse collapse navbar-responsive-collapse project-specific" data-project-id="4423800">
    <ul class="nav navbar-nav">
            <li class="">
                <a href="../index.html"><i class="glyphicon glyphicon-home"></i> All Applications</a>
            </li>



                <li class="">
                    <a href="report_index_kafka_clients_sb_sample.html">
                        <i class="glyphicon glyphicon-dashboard"></i>
                      Dashboard
                    </a>
                </li>


                <li class="">
                    <a href="migration_issues.html">
                        <i class="glyphicon glyphicon-warning-sign"></i>
                      Issues
                    </a>
                </li>


                <li class="">
                    <a href="ApplicationDetails_kafka_clients_sb_sample.html">
                        <i class="glyphicon glyphicon-th-list"></i>
                      Application Details
                    </a>
                </li>


                <li class="">
                    <a href="techReport_kafka_clients_sb_sample.html">
                        <i class="fa fa-rocket"></i>
                      Technologies
                    </a>
                </li>


                <li class="">
                    <a href="dependency_graph_report.html">
                        <i class="glyphicon glyphicon-tree-deciduous"></i>
                      Dependencies Graph
                    </a>
                </li>


                <li class="">
                    <a href="Unparsable_kafka_clients_sb_sample.html">
                        <i class="glyphicon glyphicon-warning-sign"></i>
                      Unparsable
                    </a>
                </li>


                <li class="">
                    <a href="dependency_report_kafka_clients_sb_sample.html">
                        <i class="glyphicon glyphicon-retweet"></i>
                      Dependencies
                    </a>
                </li>


                <li class="">
                    <a href="remotereport_kafka_clients_sb_sample.html">
                        <i class="glyphicon service-nav-logo"></i>
                      Remote Services
                    </a>
                </li>


                <li class="">
                    <a href="ignoredfiles_kafka_clients_sb_sample.html">
                        <i class="glyphicon glyphicon-eye-close"></i>
                      Ignored Files
                    </a>
                </li>


                <li class="">
                    <a href="about_kafka_clients_sb_sample.html">
                        <i class="fa fa-question-circle"></i>
                      About
                    </a>
                </li>
    </ul>
    <ul class="nav navbar-nav navbar-right">
<li>
    <a href="#" class="feedback-nav-btn jiraFeedbackTrigger"><i class="glyphicon glyphicon-comment"></i> Send Feedback </a>
</li>


    <script type="text/javascript" src="https://issues.redhat.com/s/f215932e68571747ac58d0f5d554396f-T/en_US-r7luaf/6346/82/1.4.16/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector.js?locale=en-US&amp;collectorId=8b9e338b"></script>

    <script type="text/javascript">

    var FEEDBACK_JS_ADDED = false;
    var FEEDBACK_FORM_TRIGGER = null;

    function displayFeedbackForm() {
        FEEDBACK_FORM_TRIGGER();
    }

    window.ATL_JQ_PAGE_PROPS = {
        "triggerFunction": function(showCollectorDialog) {
            FEEDBACK_FORM_TRIGGER = showCollectorDialog;
        }
    };

    document.addEventListener("DOMContentLoaded", function(event) {
            jQuery(".jiraFeedbackTrigger").click(function(e) {
                e.preventDefault();
                displayFeedbackForm();
            });
    });
    </script>
    </ul>
                </div><!-- /.nav-collapse -->
    </div>


    <div class="container-fluid" role="main">
        <div class="row">
            <div class="page-header page-header-no-border">
                <h1>
                    <div class="main">Source Report
                    <i class="glyphicon glyphicon-info-sign" data-toggle="tooltip" data-placement=right title="This report displays what Tackle Analysis found in individual files. Each item is shown below the line it was found on, and next to it, you may find a link to the rule which it was found by."></i></div>

                        <div class="path project-specific" data-project-id="4423800">
                            kafka-clients-sb-sample.jar/BOOT-INF/lib/netty-common-4.1.51.Final.jar/io/netty/util/Recycler.java
                        </div>
                </h1>
            </div>
        </div>

        <div class="row">
            <div class="container-fluid theme-showcase" role="main">

                <div class="panel panel-primary">
                    <div class="panel-heading">
                        <h3 class="panel-title">Information</h3>
                    </div>
                    <div class="panel-body" style="overflow: auto;">

                        <!--<div style="height: 120pt; float:left;"></div> Keeps the minimal height. -->
                        <div class="points" style="text-align: center; color: #00254b; padding-bottom: 1ex;">
                            <div class="number">0</div>
                            <div>Story Points</div>
                        </div>

                        <div class="info" style="margin-left: 95pt;">


                                <h4>Technologies</h4>
                                <div class="technologies" style="overflow: auto"><!-- "auto" to contain all the tags. -->
                                        <span class="label label-info" title="INFORMATIONAL">Decompiled Java File</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                        <span class="label label-info" title="INFORMATIONAL">Java Threads</span>
                                </div>

                                <ul class="classifications">
                                            <li>
                                                <div class="title">
                                                    <em>Threads</em>
<a title='View Rule: javase-01000' href='windup_ruleproviders.html#javase-01000'><span class='glyphicon glyphicon-link rule-link'></span></a>                                                </div>
                                                <div class="desc">The application uses Thread APIs.</div>
                                            </li>
                                </ul>


                            <div style="clear: both;"/><!-- Snaps under the height keeper. Yes, the same effect could be achieved by a table. -->
                        </div><!-- .info -->
                    </div>
                </div>



                <pre id="source">
package io.netty.util;

import io.netty.util.concurrent.FastThreadLocal;
import io.netty.util.internal.MathUtil;
import io.netty.util.internal.SystemPropertyUtil;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;
import java.lang.ref.WeakReference;
import java.util.Arrays;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.atomic.AtomicInteger;

public abstract class Recycler&lt;T&gt; {
   private static final InternalLogger logger = InternalLoggerFactory.getInstance(Recycler.class);
   private static final Recycler.Handle NOOP_HANDLE = new Recycler.Handle() {
      public void recycle(Object object) {
      }
   };
   private static final AtomicInteger ID_GENERATOR = new AtomicInteger(Integer.MIN_VALUE);
   private static final int OWN_THREAD_ID;
   private static final int DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD = 4096;
   private static final int DEFAULT_MAX_CAPACITY_PER_THREAD;
   private static final int INITIAL_CAPACITY;
   private static final int MAX_SHARED_CAPACITY_FACTOR;
   private static final int MAX_DELAYED_QUEUES_PER_THREAD;
   private static final int LINK_CAPACITY;
   private static final int RATIO;
   private static final int DELAYED_QUEUE_RATIO;
   private final int maxCapacityPerThread;
   private final int maxSharedCapacityFactor;
   private final int interval;
   private final int maxDelayedQueuesPerThread;
   private final int delayedQueueInterval;
   private final FastThreadLocal&lt;Recycler.Stack&lt;T&gt;&gt; threadLocal;
   private static final FastThreadLocal&lt;Map&lt;Recycler.Stack&lt;?&gt;, Recycler.WeakOrderQueue&gt;&gt; DELAYED_RECYCLED;

   protected Recycler() {
      this(DEFAULT_MAX_CAPACITY_PER_THREAD);
   }

   protected Recycler(int maxCapacityPerThread) {
      this(maxCapacityPerThread, MAX_SHARED_CAPACITY_FACTOR);
   }

   protected Recycler(int maxCapacityPerThread, int maxSharedCapacityFactor) {
      this(maxCapacityPerThread, maxSharedCapacityFactor, RATIO, MAX_DELAYED_QUEUES_PER_THREAD);
   }

   protected Recycler(int maxCapacityPerThread, int maxSharedCapacityFactor, int ratio, int maxDelayedQueuesPerThread) {
      this(maxCapacityPerThread, maxSharedCapacityFactor, ratio, maxDelayedQueuesPerThread, DELAYED_QUEUE_RATIO);
   }

   protected Recycler(int maxCapacityPerThread, int maxSharedCapacityFactor, int ratio, int maxDelayedQueuesPerThread, int delayedQueueRatio) {
      this.threadLocal = new FastThreadLocal&lt;Recycler.Stack&lt;T&gt;&gt;() {
         protected Recycler.Stack&lt;T&gt; initialValue() {
            return new Recycler.Stack(Recycler.this, Thread.currentThread(), Recycler.this.maxCapacityPerThread, Recycler.this.maxSharedCapacityFactor, Recycler.this.interval, Recycler.this.maxDelayedQueuesPerThread, Recycler.this.delayedQueueInterval);
         }

         protected void onRemoval(Recycler.Stack&lt;T&gt; value) {
            if (value.threadRef.get() == Thread.currentThread() &amp;&amp; Recycler.DELAYED_RECYCLED.isSet()) {
               ((Map)Recycler.DELAYED_RECYCLED.get()).remove(value);
            }

         }
      };
      this.interval = Math.max(0, ratio);
      this.delayedQueueInterval = Math.max(0, delayedQueueRatio);
      if (maxCapacityPerThread &lt;= 0) {
         this.maxCapacityPerThread = 0;
         this.maxSharedCapacityFactor = 1;
         this.maxDelayedQueuesPerThread = 0;
      } else {
         this.maxCapacityPerThread = maxCapacityPerThread;
         this.maxSharedCapacityFactor = Math.max(1, maxSharedCapacityFactor);
         this.maxDelayedQueuesPerThread = Math.max(0, maxDelayedQueuesPerThread);
      }

   }

   public final T get() {
      if (this.maxCapacityPerThread == 0) {
         return this.newObject(NOOP_HANDLE);
      } else {
         Recycler.Stack&lt;T&gt; stack = (Recycler.Stack)this.threadLocal.get();
         Recycler.DefaultHandle&lt;T&gt; handle = stack.pop();
         if (handle == null) {
            handle = stack.newHandle();
            handle.value = this.newObject(handle);
         }

         return handle.value;
      }
   }

   /** @deprecated */
   @Deprecated
   public final boolean recycle(T o, Recycler.Handle&lt;T&gt; handle) {
      if (handle == NOOP_HANDLE) {
         return false;
      } else {
         Recycler.DefaultHandle&lt;T&gt; h = (Recycler.DefaultHandle)handle;
         if (h.stack.parent != this) {
            return false;
         } else {
            h.recycle(o);
            return true;
         }
      }
   }

   final int threadLocalCapacity() {
      return ((Recycler.Stack)this.threadLocal.get()).elements.length;
   }

   final int threadLocalSize() {
      return ((Recycler.Stack)this.threadLocal.get()).size;
   }

   protected abstract T newObject(Recycler.Handle&lt;T&gt; var1);

   static {
      OWN_THREAD_ID = ID_GENERATOR.getAndIncrement();
      int maxCapacityPerThread = SystemPropertyUtil.getInt(&quot;io.netty.recycler.maxCapacityPerThread&quot;, SystemPropertyUtil.getInt(&quot;io.netty.recycler.maxCapacity&quot;, 4096));
      if (maxCapacityPerThread &lt; 0) {
         maxCapacityPerThread = 4096;
      }

      DEFAULT_MAX_CAPACITY_PER_THREAD = maxCapacityPerThread;
      MAX_SHARED_CAPACITY_FACTOR = Math.max(2, SystemPropertyUtil.getInt(&quot;io.netty.recycler.maxSharedCapacityFactor&quot;, 2));
      MAX_DELAYED_QUEUES_PER_THREAD = Math.max(0, SystemPropertyUtil.getInt(&quot;io.netty.recycler.maxDelayedQueuesPerThread&quot;, NettyRuntime.availableProcessors() * 2));
      LINK_CAPACITY = MathUtil.safeFindNextPositivePowerOfTwo(Math.max(SystemPropertyUtil.getInt(&quot;io.netty.recycler.linkCapacity&quot;, 16), 16));
      RATIO = Math.max(0, SystemPropertyUtil.getInt(&quot;io.netty.recycler.ratio&quot;, 8));
      DELAYED_QUEUE_RATIO = Math.max(0, SystemPropertyUtil.getInt(&quot;io.netty.recycler.delayedQueue.ratio&quot;, RATIO));
      if (logger.isDebugEnabled()) {
         if (DEFAULT_MAX_CAPACITY_PER_THREAD == 0) {
            logger.debug(&quot;-Dio.netty.recycler.maxCapacityPerThread: disabled&quot;);
            logger.debug(&quot;-Dio.netty.recycler.maxSharedCapacityFactor: disabled&quot;);
            logger.debug(&quot;-Dio.netty.recycler.linkCapacity: disabled&quot;);
            logger.debug(&quot;-Dio.netty.recycler.ratio: disabled&quot;);
            logger.debug(&quot;-Dio.netty.recycler.delayedQueue.ratio: disabled&quot;);
         } else {
            logger.debug(&quot;-Dio.netty.recycler.maxCapacityPerThread: {}&quot;, DEFAULT_MAX_CAPACITY_PER_THREAD);
            logger.debug(&quot;-Dio.netty.recycler.maxSharedCapacityFactor: {}&quot;, MAX_SHARED_CAPACITY_FACTOR);
            logger.debug(&quot;-Dio.netty.recycler.linkCapacity: {}&quot;, LINK_CAPACITY);
            logger.debug(&quot;-Dio.netty.recycler.ratio: {}&quot;, RATIO);
            logger.debug(&quot;-Dio.netty.recycler.delayedQueue.ratio: {}&quot;, DELAYED_QUEUE_RATIO);
         }
      }

      INITIAL_CAPACITY = Math.min(DEFAULT_MAX_CAPACITY_PER_THREAD, 256);
      DELAYED_RECYCLED = new FastThreadLocal&lt;Map&lt;Recycler.Stack&lt;?&gt;, Recycler.WeakOrderQueue&gt;&gt;() {
         protected Map&lt;Recycler.Stack&lt;?&gt;, Recycler.WeakOrderQueue&gt; initialValue() {
            return new WeakHashMap();
         }
      };
   }

   private static final class Stack&lt;T&gt; {
      final Recycler&lt;T&gt; parent;
      final WeakReference&lt;Thread&gt; threadRef;
      final AtomicInteger availableSharedCapacity;
      private final int maxDelayedQueues;
      private final int maxCapacity;
      private final int interval;
      private final int delayedQueueInterval;
      Recycler.DefaultHandle&lt;?&gt;[] elements;
      int size;
      private int handleRecycleCount;
      private Recycler.WeakOrderQueue cursor;
      private Recycler.WeakOrderQueue prev;
      private volatile Recycler.WeakOrderQueue head;

      Stack(Recycler&lt;T&gt; parent, Thread thread, int maxCapacity, int maxSharedCapacityFactor, int interval, int maxDelayedQueues, int delayedQueueInterval) {
         this.parent = parent;
         this.threadRef = new WeakReference(thread);
         this.maxCapacity = maxCapacity;
         this.availableSharedCapacity = new AtomicInteger(Math.max(maxCapacity / maxSharedCapacityFactor, Recycler.LINK_CAPACITY));
         this.elements = new Recycler.DefaultHandle[Math.min(Recycler.INITIAL_CAPACITY, maxCapacity)];
         this.interval = interval;
         this.delayedQueueInterval = delayedQueueInterval;
         this.handleRecycleCount = interval;
         this.maxDelayedQueues = maxDelayedQueues;
      }

      synchronized void setHead(Recycler.WeakOrderQueue queue) {
         queue.setNext(this.head);
         this.head = queue;
      }

      int increaseCapacity(int expectedCapacity) {
         int newCapacity = this.elements.length;
         int maxCapacity = this.maxCapacity;

         do {
            newCapacity &lt;&lt;= 1;
         } while(newCapacity &lt; expectedCapacity &amp;&amp; newCapacity &lt; maxCapacity);

         newCapacity = Math.min(newCapacity, maxCapacity);
         if (newCapacity != this.elements.length) {
            this.elements = (Recycler.DefaultHandle[])Arrays.copyOf(this.elements, newCapacity);
         }

         return newCapacity;
      }

      Recycler.DefaultHandle&lt;T&gt; pop() {
         int size = this.size;
         if (size == 0) {
            if (!this.scavenge()) {
               return null;
            }

            size = this.size;
            if (size &lt;= 0) {
               return null;
            }
         }

         --size;
         Recycler.DefaultHandle ret = this.elements[size];
         this.elements[size] = null;
         this.size = size;
         if (ret.lastRecycledId != ret.recycleId) {
            throw new IllegalStateException(&quot;recycled multiple times&quot;);
         } else {
            ret.recycleId = 0;
            ret.lastRecycledId = 0;
            return ret;
         }
      }

      private boolean scavenge() {
         if (this.scavengeSome()) {
            return true;
         } else {
            this.prev = null;
            this.cursor = this.head;
            return false;
         }
      }

      private boolean scavengeSome() {
         Recycler.WeakOrderQueue cursor = this.cursor;
         Recycler.WeakOrderQueue prev;
         if (cursor == null) {
            prev = null;
            cursor = this.head;
            if (cursor == null) {
               return false;
            }
         } else {
            prev = this.prev;
         }

         boolean success = false;

         Recycler.WeakOrderQueue next;
         do {
            if (cursor.transfer(this)) {
               success = true;
               break;
            }

            next = cursor.getNext();
            if (cursor.get() == null) {
               if (cursor.hasFinalData()) {
                  while(cursor.transfer(this)) {
                     success = true;
                  }
               }

               if (prev != null) {
                  cursor.reclaimAllSpaceAndUnlink();
                  prev.setNext(next);
               }
            } else {
               prev = cursor;
            }

            cursor = next;
         } while(next != null &amp;&amp; !success);

         this.prev = prev;
         this.cursor = cursor;
         return success;
      }

      void push(Recycler.DefaultHandle&lt;?&gt; item) {
         Thread currentThread = Thread.currentThread();
         if (this.threadRef.get() == currentThread) {
            this.pushNow(item);
         } else {
            this.pushLater(item, currentThread);
         }

      }

      private void pushNow(Recycler.DefaultHandle&lt;?&gt; item) {
         if ((item.recycleId | item.lastRecycledId) != 0) {
            throw new IllegalStateException(&quot;recycled already&quot;);
         } else {
            item.recycleId = item.lastRecycledId = Recycler.OWN_THREAD_ID;
            int size = this.size;
            if (size &lt; this.maxCapacity &amp;&amp; !this.dropHandle(item)) {
               if (size == this.elements.length) {
                  this.elements = (Recycler.DefaultHandle[])Arrays.copyOf(this.elements, Math.min(size &lt;&lt; 1, this.maxCapacity));
               }

               this.elements[size] = item;
               this.size = size + 1;
            }
         }
      }

      private void pushLater(Recycler.DefaultHandle&lt;?&gt; item, Thread thread) {
         if (this.maxDelayedQueues != 0) {
            Map&lt;Recycler.Stack&lt;?&gt;, Recycler.WeakOrderQueue&gt; delayedRecycled = (Map)Recycler.DELAYED_RECYCLED.get();
            Recycler.WeakOrderQueue queue = (Recycler.WeakOrderQueue)delayedRecycled.get(this);
            if (queue == null) {
               if (delayedRecycled.size() &gt;= this.maxDelayedQueues) {
                  delayedRecycled.put(this, Recycler.WeakOrderQueue.DUMMY);
                  return;
               }

               if ((queue = this.newWeakOrderQueue(thread)) == null) {
                  return;
               }

               delayedRecycled.put(this, queue);
            } else if (queue == Recycler.WeakOrderQueue.DUMMY) {
               return;
            }

            queue.add(item);
         }
      }

      private Recycler.WeakOrderQueue newWeakOrderQueue(Thread thread) {
         return Recycler.WeakOrderQueue.newQueue(this, thread);
      }

      boolean dropHandle(Recycler.DefaultHandle&lt;?&gt; handle) {
         if (!handle.hasBeenRecycled) {
            if (this.handleRecycleCount &lt; this.interval) {
               ++this.handleRecycleCount;
               return true;
            }

            this.handleRecycleCount = 0;
            handle.hasBeenRecycled = true;
         }

         return false;
      }

      Recycler.DefaultHandle&lt;T&gt; newHandle() {
         return new Recycler.DefaultHandle(this);
      }
   }

   private static final class WeakOrderQueue extends WeakReference&lt;Thread&gt; {
      static final Recycler.WeakOrderQueue DUMMY = new Recycler.WeakOrderQueue();
      private final Recycler.WeakOrderQueue.Head head;
      private Recycler.WeakOrderQueue.Link tail;
      private Recycler.WeakOrderQueue next;
      private final int id;
      private final int interval;
      private int handleRecycleCount;

      private WeakOrderQueue() {
         super((Object)null);
         this.id = Recycler.ID_GENERATOR.getAndIncrement();
         this.head = new Recycler.WeakOrderQueue.Head((AtomicInteger)null);
         this.interval = 0;
      }

      private WeakOrderQueue(Recycler.Stack&lt;?&gt; stack, Thread thread) {
         super(thread);
         this.id = Recycler.ID_GENERATOR.getAndIncrement();
         this.tail = new Recycler.WeakOrderQueue.Link();
         this.head = new Recycler.WeakOrderQueue.Head(stack.availableSharedCapacity);
         this.head.link = this.tail;
         this.interval = stack.delayedQueueInterval;
         this.handleRecycleCount = this.interval;
      }

      static Recycler.WeakOrderQueue newQueue(Recycler.Stack&lt;?&gt; stack, Thread thread) {
         if (!Recycler.WeakOrderQueue.Head.reserveSpaceForLink(stack.availableSharedCapacity)) {
            return null;
         } else {
            Recycler.WeakOrderQueue queue = new Recycler.WeakOrderQueue(stack, thread);
            stack.setHead(queue);
            return queue;
         }
      }

      Recycler.WeakOrderQueue getNext() {
         return this.next;
      }

      void setNext(Recycler.WeakOrderQueue next) {
         assert next != this;

         this.next = next;
      }

      void reclaimAllSpaceAndUnlink() {
         this.head.reclaimAllSpaceAndUnlink();
         this.next = null;
      }

      void add(Recycler.DefaultHandle&lt;?&gt; handle) {
         handle.lastRecycledId = this.id;
         if (this.handleRecycleCount &lt; this.interval) {
            ++this.handleRecycleCount;
         } else {
            this.handleRecycleCount = 0;
            Recycler.WeakOrderQueue.Link tail = this.tail;
            int writeIndex;
            if ((writeIndex = tail.get()) == Recycler.LINK_CAPACITY) {
               Recycler.WeakOrderQueue.Link link = this.head.newLink();
               if (link == null) {
                  return;
               }

               this.tail = tail = tail.next = link;
               writeIndex = tail.get();
            }

            tail.elements[writeIndex] = handle;
            handle.stack = null;
            tail.lazySet(writeIndex + 1);
         }
      }

      boolean hasFinalData() {
         return this.tail.readIndex != this.tail.get();
      }

      boolean transfer(Recycler.Stack&lt;?&gt; dst) {
         Recycler.WeakOrderQueue.Link head = this.head.link;
         if (head == null) {
            return false;
         } else {
            if (head.readIndex == Recycler.LINK_CAPACITY) {
               if (head.next == null) {
                  return false;
               }

               head = head.next;
               this.head.relink(head);
            }

            int srcStart = head.readIndex;
            int srcEnd = head.get();
            int srcSize = srcEnd - srcStart;
            if (srcSize == 0) {
               return false;
            } else {
               int dstSize = dst.size;
               int expectedCapacity = dstSize + srcSize;
               if (expectedCapacity &gt; dst.elements.length) {
                  int actualCapacity = dst.increaseCapacity(expectedCapacity);
                  srcEnd = Math.min(srcStart + actualCapacity - dstSize, srcEnd);
               }

               if (srcStart != srcEnd) {
                  Recycler.DefaultHandle[] srcElems = head.elements;
                  Recycler.DefaultHandle[] dstElems = dst.elements;
                  int newDstSize = dstSize;

                  for(int i = srcStart; i &lt; srcEnd; ++i) {
                     Recycler.DefaultHandle&lt;?&gt; element = srcElems[i];
                     if (element.recycleId == 0) {
                        element.recycleId = element.lastRecycledId;
                     } else if (element.recycleId != element.lastRecycledId) {
                        throw new IllegalStateException(&quot;recycled already&quot;);
                     }

                     srcElems[i] = null;
                     if (!dst.dropHandle(element)) {
                        element.stack = dst;
                        dstElems[newDstSize++] = element;
                     }
                  }

                  if (srcEnd == Recycler.LINK_CAPACITY &amp;&amp; head.next != null) {
                     this.head.relink(head.next);
                  }

                  head.readIndex = srcEnd;
                  if (dst.size == newDstSize) {
                     return false;
                  } else {
                     dst.size = newDstSize;
                     return true;
                  }
               } else {
                  return false;
               }
            }
         }
      }

      private static final class Head {
         private final AtomicInteger availableSharedCapacity;
         Recycler.WeakOrderQueue.Link link;

         Head(AtomicInteger availableSharedCapacity) {
            this.availableSharedCapacity = availableSharedCapacity;
         }

         void reclaimAllSpaceAndUnlink() {
            Recycler.WeakOrderQueue.Link head = this.link;
            this.link = null;

            int reclaimSpace;
            Recycler.WeakOrderQueue.Link next;
            for(reclaimSpace = 0; head != null; head = next) {
               reclaimSpace += Recycler.LINK_CAPACITY;
               next = head.next;
               head.next = null;
            }

            if (reclaimSpace &gt; 0) {
               this.reclaimSpace(reclaimSpace);
            }

         }

         private void reclaimSpace(int space) {
            this.availableSharedCapacity.addAndGet(space);
         }

         void relink(Recycler.WeakOrderQueue.Link link) {
            this.reclaimSpace(Recycler.LINK_CAPACITY);
            this.link = link;
         }

         Recycler.WeakOrderQueue.Link newLink() {
            return reserveSpaceForLink(this.availableSharedCapacity) ? new Recycler.WeakOrderQueue.Link() : null;
         }

         static boolean reserveSpaceForLink(AtomicInteger availableSharedCapacity) {
            int available;
            do {
               available = availableSharedCapacity.get();
               if (available &lt; Recycler.LINK_CAPACITY) {
                  return false;
               }
            } while(!availableSharedCapacity.compareAndSet(available, available - Recycler.LINK_CAPACITY));

            return true;
         }
      }

      static final class Link extends AtomicInteger {
         final Recycler.DefaultHandle&lt;?&gt;[] elements;
         int readIndex;
         Recycler.WeakOrderQueue.Link next;

         Link() {
            this.elements = new Recycler.DefaultHandle[Recycler.LINK_CAPACITY];
         }
      }
   }

   private static final class DefaultHandle&lt;T&gt; implements Recycler.Handle&lt;T&gt; {
      int lastRecycledId;
      int recycleId;
      boolean hasBeenRecycled;
      Recycler.Stack&lt;?&gt; stack;
      Object value;

      DefaultHandle(Recycler.Stack&lt;?&gt; stack) {
         this.stack = stack;
      }

      public void recycle(Object object) {
         if (object != this.value) {
            throw new IllegalArgumentException(&quot;object does not belong to handle&quot;);
         } else {
            Recycler.Stack&lt;?&gt; stack = this.stack;
            if (this.lastRecycledId == this.recycleId &amp;&amp; stack != null) {
               stack.push(this);
            } else {
               throw new IllegalStateException(&quot;recycled already&quot;);
            }
         }
      }
   }

   public interface Handle&lt;T&gt; extends io.netty.util.internal.ObjectPool.Handle&lt;T&gt; {
   }
}
</pre>
            </div> <!-- /container -->
        </div><!-- /row-->
    </div><!-- /container main-->


<div style="text-align: left; font-size: small; color: gray; font-style: italic;">Page generated: Feb 15, 2023, 10:00:27 PM</div>

    <script src="resources/js/jquery-migrate-1.4.1.min.js"></script>
    <script src="resources/js/bootstrap.min.js"></script>

    <script type="text/javascript" src="resources/libraries/jquery-ui/jquery.ui.widget.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.min.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.java-properties.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.java-manifest.js"></script>
    <script type="text/javascript" src="resources/libraries/sausage/jquery.sausage.min.js"></script>

    <script type="text/javascript">
        var script   = document.createElement("script");
        script.type  = "text/javascript";
            script.src   = "resources/js/navbar.js";
        document.body.appendChild(script);
    </script>

    <script type="text/javascript">
        $(window).on("hashchange", function () {
            window.scrollTo(window.scrollX, window.scrollY - 50);
        });
        function offsetAnchor() {
            if(location.hash.length !== 0) {
                window.scrollTo(window.scrollX, window.scrollY - 50);
            }
        }
        window.setTimeout(function() {
            offsetAnchor();
        }, 1);
        $(document).ready(function(){
            $("pre").snippet("java",{style:"ide-eclipse", showNum:true,boxFill:"#ffeeb9", box: "" });



            if (location.hash) {
                var atag = $("a[name='" + location.hash.substr(1)  +  "']");
                $('html,body').animate({scrollTop: atag.offset().top - 150},'slow');
            }

            $('code[class]').each(function(){
                 var codeSyntax = ($(this).attr('class'));
                 if(codeSyntax) {
                    $(this).parent().snippet(codeSyntax,{style:'ide-eclipse', menu:false, showNum:false});
                 }
            });
            $(window).sausage({ page: 'li.box' });
            $(window).resize(function () {
                $('div.sausage-set').css('top', parseInt($('#main-navbar').css("height")));
            });

            // Deprecated
            // $(window).load(function () {
            //     $('div.sausage-set').css('top', parseInt($('#main-navbar').css("height")));
            // });
            $(window).on('load', function () {
                $('div.sausage-set').css('top', parseInt($('#main-navbar').css("height")));
            });
        });

        function qs(key) {
            key = key.replace(/[*+?^$.\[\]{}()|\\\/]/g, "\\$&"); // escape RegEx meta chars
            var match = location.search.match(new RegExp("[?&]"+key+"=([^&]+)(&|$)"));
            return match && decodeURIComponent(match[1].replace(/\+/g, " "));
        }

        $(document).ready(function() {
            var defaultProjectID = 4423800;
            var selectedProject = qs("project");
            if (!selectedProject)
                selectedProject = defaultProjectID;

            $(".project-specific").each(function(index, element) {
                var currentProject = $(element).data("project-id");

                if (currentProject == selectedProject)
                    $(element).show();
                else
                    $(element).remove();
            });
            $("#main-navbar").show();
        });
    </script>
    <script>$(document).ready(function(){$('[data-toggle="tooltip"]').tooltip();});</script>
</body>
</html>
